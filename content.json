[{"title":"ES6 学习笔记","date":"2017-12-14T02:40:09.000Z","path":"2017/12/14/ES6-学习笔记/","text":"ECMAScript 6 在接下来的一段时间内将成为 ECMAScript的一个标准。这个标准预计在今年的时候就会被签署，不管在Github,还是在很多社区，javascript爱好者已经早已开始拥抱变化，享受ES6 带来的美好,这篇文章将介绍ES6的一些新特性。由于ES6 还没有很好地被浏览器支持，所以这篇文章的ES6代码将使用 Babel 进行编译。 ECMAScript 6 的新特性箭头（Arrow）=&gt; 是function的简写形式，支持expression 和 statement 两种形式。同时一点很重要的是它拥有词法作用域的this值，帮你很好的解决this的指向问题，这是一个很酷的方式，可以帮你减少一些代码的编写，先来看看它的语法。12345([param] [, param]) =&gt; &#123; statements&#125;param =&gt; expression 类（class）ES6 引入了class（类），让javascript的面向对象编程变得更加容易清晰和容易理解。类只是基于原型的面向对象模式的语法糖。1234567891011121314151617181920212223242526272829303132333435363738 class Animal &#123; // 构造方法，实例化的时候将会被调用，如果不指定，那么会有一个不带参数的默认构造函数. constructor(name,color) &#123; this.name = name; this.color = color; &#125; // toString 是原型对象上的属性 toString() &#123; console.log('name:' + this.name + ',color:' + this.color); &#125; &#125; var animal = new Animal('dog','white');animal.toString();console.log(animal.hasOwnProperty('name')); //trueconsole.log(animal.hasOwnProperty('toString')); // falseconsole.log(animal.__proto__.hasOwnProperty('toString')); // trueclass Cat extends Animal &#123; constructor(action) &#123; // 子类必须要在constructor中指定super 方法，否则在新建实例的时候会报错. // 如果没有置顶consructor,默认带super方法的constructor将会被添加、 super('cat','white'); this.action = action; &#125; toString() &#123; console.log(super.toString()); &#125;&#125;var cat = new Cat('catch')cat.toString();// 实例cat 是 Cat 和 Animal 的实例，和Es5完全一致。console.log(cat instanceof Cat); // trueconsole.log(cat instanceof Animal); // true 类的 prototype 属性和 proto 属性我们已经了解到一个实例化对象会有一个 __proto__ 指向构造函数的 prototype 属性。在 class 中。同时具有 __proto__ 和 prototype 两个属性，存在两条继承链。 子类的 __proto__ 属性，表示构造函数的继承，总是指向父类。 子类的 prototype 的 __proto__ 属性表示方法的继承，总是指向父类的 prototype属性。123class Cat extends Animal &#123;&#125;console.log(Cat.__proto__ === Animal); // trueconsole.log(Cat.prototype.__proto__ === Animal.prototype); // true Module到目前为止,javascript (ES5及以前) 还不能支持原生的模块化，大多数的解决方案都是通过引用外部的库来实现模块化。比如 遵循CMD规范的 Seajs 和AMD的 RequireJS 。在ES6中，模块将作为重要的组成部分被添加进来。模块的功能主要由 export 和 import 组成.每一个模块都有自己单独的作用域，模块之间的相互调用关系是通过 export 来规定模块对外暴露的接口，通过import来引用其它模块提供的接口。同时还为模块创造了命名空间，防止函数的命名冲突。 export,import 命令12//test.js export var name = 'Rainbow' ES6将一个文件视为一个模块，上面的模块通过 export 向外输出了一个变量。一个模块也可以同时往外面输出多个变量。1234 //test.jsvar name = 'Rainbow';var age = '24';export &#123;name, age&#125;; 定义好模块的输出以后就可以在另外一个模块通过import引用。12 //index.jsimport &#123;name, age&#125; from './test.js' let与const 关键字可以把let看成var，只是它定义的变量被限定在了特定范围内才能使用，而离开这个范围则无效。const则很直观，用来定义常量，即无法被更改值的变量。12for (let i=0;i&lt;2;i++)console.log(i);//输出: 0,1console.log(i);//输出：undefined,严格模式下会报错 for of 值遍历我们都知道for in 循环用于遍历数组，类数组或对象，ES6中新引入的for of循环功能相似，不同的是每次循环它提供的不是序号而是值。12345var someArray = [ \"a\", \"b\", \"c\" ]; for (v of someArray) &#123; console.log(v);//输出 a,b,c&#125;","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yaochuxia.github.io/tags/Javascript/"}]},{"title":"React生命周期详解","date":"2017-12-13T13:11:56.000Z","path":"2017/12/13/React生命周期详解/","text":"React严格意义了组件的生命周期会经历如下三个流程： 装载过程（Mount），组件第一次在DOM树渲染的过程。 更新过程（Update），当组件被重新渲染的过程。 卸载过程（Unmount），组件重DOM树中删除的过程。执行3个过程的调用函数就是声明周期函数。React 生命周期分为三种状态 1. 初始化 2.更新 3.销毁 初始化1、getDefaultProps() 设置默认的props，也可以用dufaultProps设置组件的默认属性. 2、getInitialState() 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props 3、componentWillMount() 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。 4、 render() react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。 5、componentDidMount() 组件渲染之后调用，只调用一次。 更新6、componentWillReceiveProps(nextProps) 组件初始化时不调用，组件接受新的props时调用。 7、shouldComponentUpdate(nextProps, nextState) react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候 8、componentWillUpdata(nextProps, nextState) 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state 9、render() 组件渲染 10、componentDidUpdate() 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。 卸载11、componentWillUnmount() 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。 装载过程该过程会依次调用如下函数： constructor():ES6类的构造函数（为了初始化state或绑定this） getInitialState():ES5中初始化state。 getDefaultProps():ES5中初始化props。在ES6中使用defaultProps()方法。 componentWillMount():在组件被挂载前调用。只执行一次。 render():渲染组件，必须实现该方法。 componentDidMount():在组件装载后调用。这时已经生成了真实的DOM节点。只执行一次。 更新过程当组件的props或者state改变时就会触发组件的更新过程。更新过程会依次执行如下函数： componentWillReceiveProps(nextProps):当父组件的render()方法执行后就会触发该方法。初始化时不调用。 shouldComponentUpdate(nextProps,nextState):当props改变或state改变时调用，初始化时不掉用，返回boolean。true表示继续执行render方法，fasle表示放弃本次渲染。 render():渲染组件。 卸载过程componentWillUnmount():将组件从DOM树移出，防止内存溢出。 组件调用123456import React from 'react'import App from './components/App.js'import &#123;render&#125; from 'mirrorx'// 启动 app，render 方法是加强版的 ReactDOM.renderrender(&lt;App/&gt;, document.getElementById('root')) 组件定义1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 import React from 'react'import mirror, &#123; actions, connect, render &#125; from 'mirrorx'// 声明 Redux state, reducer 和 action，// 所有的 action 都会以相同名称赋值到全局的 actions 对象上mirror.model(&#123; name: 'app', initialState: 0, reducers: &#123; increment(state) &#123; return state + 1 &#125;, decrement(state) &#123; return state - 1 &#125; &#125;, effects: &#123; async incrementAsync() &#123; await new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve() &#125;, 1000) &#125;) actions.app.increment() &#125; &#125;&#125;)class App extends React.Component &#123; constructor(props)&#123; super(props) console.log(\"---初始化组件---\") &#125; componentWillMount()&#123; console.log(\"---组件挂载前---\") &#125; componentDidMount()&#123; console.log(\"---组件挂载后---\") &#125; componentWillReceiveProps(nextProps)&#123; console.log(\"---父组件重新渲染---\") &#125; shouldComponentUpdate(nextProps,nextState)&#123; console.log(\"---组件接受到重绘状态---\") if(this.props != nextProps || this.state != nextState) return true &#125; render() &#123; console.log(\"---组件渲染---\") const props = this.props return ( &lt;div&gt; &lt;h1&gt;&#123;props.count&#125;&lt;/h1&gt; &#123;/* 调用 actions 上的方法来 dispatch action */&#125; &lt;button onClick=&#123;() =&gt; actions.app.decrement()&#125; style=&#123;&#123; margin: \"5px\" &#125;&#125;&gt;-&lt;/button&gt; &lt;button onClick=&#123;() =&gt; actions.app.increment()&#125; style=&#123;&#123; margin: \"5px\" &#125;&#125;&gt;+&lt;/button&gt; &#123;/* dispatch async action */&#125; &lt;button onClick=&#123;() =&gt; actions.app.incrementAsync()&#125; style=&#123;&#123; margin: \"5px\" &#125;&#125;&gt;+ Async&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default connect((state) =&gt; &#123; return &#123; count: state.app &#125;&#125;)(App)","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yaochuxia.github.io/tags/Javascript/"}]},{"title":"React数据流和组件间的通信总结","date":"2017-10-30T08:37:29.000Z","path":"2017/10/30/React数据流和组件间的通信总结/","text":"今天来给大家总结下React的单向数据流与组件间的沟通。 首先，我认为使用React的最大好处在于：功能组件化，遵守前端可维护的原则。 先介绍单向数据流吧。 React单向数据流:React时单向数据流，数据主要从父节点传递到子节点（通过props）。如果顶层（父级）的某个props改变了，React会重现渲染所有的字节点。 刚才我们提到了Props，怎么理解Props呢？Propsprops是property的缩写，可以理解为HTML标签的attribute。不可以使用this.props直接修改props，因为props是只读的，props是用于整个组件树中传递数据和配置。在当组件访问props，使用this.props。 贴出props的代码：1234567891011121314151617var React = require(&apos;react&apos;);var ReactDom = require(&apos;react-dom&apos;);var Box = React.createClass(&#123; render: function()&#123; var data = this.props.data;//此时this.props指的是Box组件中的属性 return( &lt;div&gt; &lt;div data=&#123;data&#125;&gt;&lt;/div&gt; &lt;/div&gt; ) &#125;&#125;); ReactDom.render( &lt;Box data=&#123;data&#125;&gt;&lt;/Box&gt;, document.getElementById(&apos;root&apos;)) data 为一个模拟数据，无具体意义，仅供举例使用。 接下来说说stateState:每个组件都有属于自己的state，state和props的区别在于前者（state）只存在于组件内，只能从当前组件调用，this.setState修改state值（不可以直接修改this.state）。一般我们更新自组件都是通过改变state值，更新新子组件的props值从而达到更新。 我们举个列子：12345678910var Box = React.createClass(&#123; getInitialState:function()&#123; return&#123; text: '' &#125; &#125;, render: function()&#123; var text = this.state.text; &#125;&#125;) 这里使用getInitialState来初始化state，例子里面state是text，然后通过this.state.text读取state值 Props与state:尽可能使用props当作数据源，state用来存放状态值（简单的数据）。也就是说咱们通常用的props传递大量数据，state用于存放组件内部的一些简单的定义数据。（需要通过大量运用react可以感受到这点）。 那么单向数据流的原理及一些概念咱么说完了，接下来咱们看看组件间是怎么进行沟通的： 一般来说，有两种沟通方式： 一、父子组件沟通 在React中，最为常见的组件沟通也就是父子了，一般情况是： 父组件更新组件状态 —–props—–&gt; 子组件更新 另一种情况是： * 子组件更新父组件状态 —–需要父组件传递回调函数—–&gt; 子组件调用触发 可能大家对于第二种子组件更新父组件状态的情况有些不理解：是这样的，一般情况下，只能由父组件通过props传递数据给子组件，使得子组件得到更新，那么现在，我们想实现 子组件更新父组件就需要 父组件通过props传递一个回调函数到子组件中，这个回调函数可以更新父组件，子组件就是 通过触发这个回调函数，从而使父组件得到更新。（类似于一种取巧的做法） 这里贴出 子组件更新父组件 代码：1234567891011121314151617181920212223242526272829303132var Son = React.createClass(&#123; render: function()&#123; return()&#123; &lt;div&gt; &#123;this.props.text&#125; &lt;botton onClick=&#123;this.props.refreshBox&#125;&gt;更新父组件&lt;/botton&gt; &lt;/div&gt; &#125; &#125;&#125;);var Box = React.createClass(&#123; getInitialState: function()&#123; return( text: &apos;&apos; ) &#125;, refreshBox:function()&#123; this.setState(&#123; text:&apos;自组件更新父组件成功&apos; &#125;) &#125;, render:function()&#123; var data = this.props.data;//此时this.props指向的是Box组件中的属性 var text = this.state.text; return( &lt;div&gt; &lt;div data=&#123;dtat&#125;&gt;&lt;/div&gt; &lt;Son text=&#123;this.state.text&#125;refreshBox=&#123;this.refreshBox.bind(this)&#125;&gt;&lt;/Son&gt; &lt;/div&gt; ) &#125;&#125;) 在这个例子中，refreshBox是父组件创建的一个回调函数，将其传入Son组件中，然后通过Son组件进行调用触发， 进而改变state，实现子组件对父组件的更新。 二、兄弟组件沟通当两个组件处于同一级时（同处父级，或者同处子级），就称为兄弟组件。 这里有两种实现方式：方式一： 按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props。 其实这种实现方式与子组件更新父组件状态的方式是大同小异的。 方式二： 方式一只适用于组件层次很少的情况，当组件层次很深的时候，整个沟通的效率就会变得很低 在这里，React官方给我们提供了一种上下文方式，可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。 但这种方法建议按需使用，可能会导致一些不可预期的错误。（比如数据传递逻辑结构不清晰） 在这里直接贴出例子： var Son = React.createClass({ render: function(){ return( &lt;div&gt; {this.props.text} &lt;botton onClick={this.context.refresh}&gt;更新父组件&lt;/botton&gt; &lt;/div&gt; ) } }); var Box = React.createClass({ getInitialState: function(){ ... }, getChildContext: function(){ return{ refresh: this.refresh() } }, refresh: function(){ return: function(e){ this.setSate({ text:&apos;跨级组件通信成功&apos; }) } }, return: function(){ var data = this.props.data;//指的是Box组件中的属性 var text = this.state.text; return( &lt;div&gt; &lt;div data={data}&gt;&lt;/div&gt; &lt;Son text={this.state.text}&gt;&lt;/Son&gt; &lt;/div&gt; ) } }) Box.childContextType = { refresh: React.PropTypes.any, text: React.PropTypes.any } 首先要对使用对象进行说明，Box.childContextType就是这样一个上下文声明，子组件调用祖先组件的方法时， 通过 this.context.[callback] 这样就可以进行祖先与子组件间的沟通了。 总结：今天在这里总结了单向数据流的概念与组件间的沟通，希望大家看后能对React一些基本原理有更深的理解，有错误的地方私信我，我改正。","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yaochuxia.github.io/tags/Javascript/"}]},{"title":"Hello World","date":"2017-10-26T05:03:34.000Z","path":"2017/10/26/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"2017前端面试常见问题","date":"2017-10-13T13:52:41.000Z","path":"2017/10/13/2017前端面试常见问题/","text":"1.html 题目 2.css题目 3.js题目 HTML1.DocType的作用？严格模式与混杂模式如何区分？它们有何意义? 1.是一个标签（Document Type），用来声明标准通用标记语言的文档类型，就是要告诉解析器，应该使用什么样的文档类型定义来解析文档，也就是html的版本类型，必须放在所有的代码和标识之上。 2.DTD的三种类型： 2.1 –严格版本：禁止所有的表现层的标识和属性 presetational/deprecatedelements(例如font)以及frameset（框架的）标签；– 2.2 过渡版本：– 2.3 框架版本： 3.标准模式：浏览器以其支持的最高标准呈现呈现页面； 混杂模式：页面以一种比较宽松的向后兼容的方式显示，浏览器会根据 DOCTYPE是否存在来选择要使用的方法，如果没有DOCTYPE,那么就是以混杂模式呈现。 2.HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ 由于它放弃了与SGML的兼容，所以其实不需要在文档开头引用DTD,因为这个声明格式再当前所有的浏览器（IE,FF,OPERA,SAFAR等）下都会以标准模式渲染，而HTML5没有DTD,也就没有严格模式与宽松模式。 3.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 行内：width与height没有作用，只有padding（margin）-left与padding(margin)-right或者line-height有作用&lt;br&gt;,&lt;span&gt;,&lt;a&gt;,&lt;b&gt;,&lt;button&gt;,&lt;em&gt;,&lt;i&gt;,&lt;iframe&gt;,&lt;img&gt;,&lt;input&gt;,&lt;label&gt;,&lt;map&gt;,&lt;select&gt;, 块级：&lt;div&gt;,&lt;p&gt;,&lt;caption&gt;,&lt;dd&gt;,&lt;dl&gt;,&lt;dt&gt;,&lt;form&gt;,&lt;h1&gt;,&lt;h…&gt;,&lt;hr&gt;,&lt;li&gt;,&lt;ol&gt;,&lt;ul&gt;,&lt;pre&gt;,&lt;table&gt;,&lt;td&gt;,&lt;th&gt;,&lt;thead&gt;,&lt;tr&gt; 1.块级元素各自占一行，垂直方向排列，可以包含行级元素和块级元素，行级元素可以转换为块级元素：display:block; 2.行内元素：会在水平方向排列，不能包含块级元素，设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效。 3.(Q2) 兼容性：display:inline-block;display:inline;zoom:1; 4.空元素:没有内容的标签，就是没有关闭标签的空元素 空元素：&lt;/b&gt;,&lt;br/&gt;,&lt;hr&gt;,&lt;input&gt;,&lt;img&gt;,&lt;meta&gt;,&lt;link&gt; 4.页面导入样式时，使用link和@import有什么区别？ Link:XHTML标签；除了可以加载CSS外，还可以定义RSS，定义rel的链接属性；当页面被加载的时候，link使用的CSS会同时被加载，故浏览者浏览的时候，会有样式； @import:是css提供的一种方式；只有当所有的界面都被下载完才会加载，所以用这个的时候，有的时候开始会没有样式； 老的浏览器不会支持只有在IE5以上才会支持。使用dom不可以控制@import 5.介绍一下你对浏览器内核的理解？ 就是解释引擎，负责对网页语法的解释并渲染（显示）网页，决定了如何显示网页的内容以及页面的格式。就是兼容性的问题。 6.常见的浏览器内核有哪些？ Trident内核—IE Gecko内核—FireFox（该内核的特点就是 开源，javascript的引擎是SpiderMonkey。） Webkit内核—safari以及chrome的原生内核。Google Chrome、360极速浏览器以及搜狗高速浏览器高速模式都是这个内核。 Blink-chrome（28及以后版本）的最新内核 Presto内核–opera浏览器 7.html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 1.正则验证：&lt;input type=&quot;email&quot; pattern=&quot;[^ @]*@[^ @]*&quot; value=&quot;&quot;&gt;无需后台检测，即可检验 2.Dataliat属性：可以实现自动补全机制，不用jqury再去实现。&lt;input list=&quot;jslib&quot; name=&quot;jslib&quot; &gt; &lt;datalist id=&quot;jslib&quot;&gt; 3.下载特性：允许强制下载文件： &lt;a href=&quot;download_pdf.php&quot; download=&quot;somefile.pdf&quot;&gt;下载PDF文件&lt;/a&gt; 4.用于绘画的 canvas 元素代替了Flash 拖拽释放(Drag and drop) API 语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 新的技术webworker, websocket, Geolocation 5.用于媒介回放的 video 和 audio 元素、 6.对本地离线存储的更好的支持、 7.新的特殊内容元素，比如 article、footer、header、nav、section、新的表单控件，比如 calendar、date、time、email、url、search。 8.新增了&lt;menu&gt;可以被用于创建传统的菜单，也可以用于工具栏和上下文菜单。&lt;figure&gt;标签使得网页文字和图片的排版更专业。 删除了： &lt;b&gt;、&lt;font&gt;、&lt;frame&gt;、&lt;center&gt;、&lt;big&gt; 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签，可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式： 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 123&lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 区分：H5简化了很多语法；例如Doctype的声明。 8.简述一下你对HTML语义化的理解？ 标签语义化就是让你更好的理解标签的含义:比如h1-6就是很明显的定义标题；就是让页面的内容结构化，便于解析；便于阅读和理解。 其实就是让你用正确的标签做正确的事情；先了解模块在页面中的职能，后编写代码。 9.HTML5的离线储存怎么使用，工作原理能不能解释一下？ 通过Manifest; Manifest是一个简单的 文本文件，它的扩展名是任意 的，定义需要缓存的文件、资源，当第一次打开时，浏览器会自动缓存相应的资源。 Manifest 的特点： 离线浏览：即当网络断开时，可以继续访问你的页面。 访问速度快：将文件缓存到本地，不需每次都从网络上请求。 稳定性：做了Manifest缓存，遇到突发网络故障或者服务器故障，继续访问本地缓存。 使用： 首先创建一个和html同名的manifest文件，比如页面为index.html，那么可以建一个index.manifest的文件，然后给index.html的html标签添加如下属性即可： 或 1、manifest 的引入可以使绝对路径也可以是相对路径 2、manifest文件你可以保存为任意的扩展名，但mine-type 必须是 text/cache-manifest。 3、manifest 标签应该包含到你需要缓存资源的页面，当第一次打开该页面时，浏览器会解析该页面中的mainfest，并缓存里面列举的资源，同时该页面也会自动会被浏览器缓存，即使该页面没有在Manifest中列出。 4、HTML5缓存可以做到以下几点：1&gt;实现图片存在客户端；2&gt;实现跨域共享客户端缓存；3&gt;做到真正的离线访问WEB应用；4&gt;实现客户端的数据库。 在H5之前，是由cookie实现客户端的缓存，将缓存信息带在HTTP请求头上，大小只有4k，会造成Domain污染H5的几种存储形式： 1&gt;本地存储(localstorage &amp;&amp; sessionstorage)： 存储形式：key–&gt;value过期时间：永久存储，永不失效，除非手动删除 大小：官方给出的文档是每个域名5M，所以需要抛出异常处理 浏览器支持情况：IE8+、Firefox、Safari3.2+、Chrome、Opera 使用方法：localstorage API介绍,resource里面看， 在console里面操作 1.getItem:取 localstorage记录 setItem:设置 removeItem:移除key:去拿一个索引 clear:删掉，清除（这个是删除掉了全部） H5可以存储的东东：数组、json数据、图片、脚本、样式文件 原理： HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 9.浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 当第一次打开该页面时，浏览器会解析该页面中的mainfest，并缓存里面列举的资源，同时该页面也会自动会被浏览器缓存，即使该页面没有在Manifest中列出。 更新缓存的方式： 更新manifest文件 通过javascript操作 清除浏览器缓存 10.请描述一下 cookies，sessionStorage 和 localStorage 的区别？ Cookie:（不能超过4k）始终在同源的Http请求中携带（即使不需要），他在浏览器和服务器之间来回传递；后两者均只在本地保存，不会自动发给服务器；只在设置的过期时间之前有用；所有同源窗口之间使用。 SessionStorge:缓存存储,存储范围大。所有的同源窗口之间共享。 LocalStrage:本地存储，仅在同浏览器，同浏览页面共享。 11.iframe有那些缺点？ 优点：1.重载页面的时候不需要重载整个页面，只需要重载页面中的一个框架页增加网页的传输速度；一般用于制作导航栏的时候使用—–现在由于他的缺点，已经使用ajax代替它实现了； iframe的缺点： 1.会产生很多页面，不容易管理 2.代码过于复杂，不太容易被浏览器的引擎解析； 3.iframe会阻塞主页面的Onload事件，即时内容为空，加载也需要时间； 12.Label的作用是什么？是怎么用的？（加 for 或 包裹） Label:用来给 input 元素定义标注（标记）。不会呈现出来任何的效果，一般可用来在该标签内点击文本，然后会触发此控件。 标签的 for 属性应当与相关元素的 id 属性相同。 用法：&lt;form&gt; &lt;label for=&quot;male&quot;&gt;Male&lt;/label&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; id=&quot;male&quot; /&gt; &lt;/form&gt; 13.HTML5的form如何关闭自动完成功能？ 自动完成功能就是：当你在文本框输入时，浏览器会根据历史纪录，提醒您，但有的时候我们要通过ajax来操作：所以需要关闭该功能 1、在IE的Internet选项菜单里的内容–自动完成里面设置 2、设置Form的autocomplete为”on”或者”off”来开启或者关闭自动完成功能 3、设置输入框的autocomplete为”on”或者”off”来开启或者关闭该输入框的自动完成功能 14.如何实现浏览器内多个标签页之间的通信? (阿里) 使用cookie，localstorage. 15.webSocket如何兼容低浏览器？(阿里) 引用WebSocket.js这个文件来兼容低版本浏览器，WebSocket.swf需 要放在与页面相同的目录下。 16.页面可见性（Page Visibility）API 可以有哪些用途？ 当可见性发生了改变的时候，会触发 visibilityState事件，通过给事件注册一个监听函数，那么就可以进行一些操作：即能够在页面切换到不可见状态时暂停执行一些不必要的操作,以减少资源的浪费. 比如当前页面在播放动画，检测到用户切换了或者最小化了该窗口，则自动停止； 有的程序会及时刷新访问界面（比如篮球比赛时的比分更新），若窗口关闭，他也会停止刷新； 17.如何在页面上实现一个圆形的可点击区域？ map+area 1234&lt;img src=\"t.jpg\" width=\"1366\" height=\"768\" border=\"0\" usemap=\"#Map\" /&gt; &lt;map name=\"Map\" id=\"Map\"&gt; &lt;area shape=\"circle\" coords=\"821,289,68\" href=\"www.baidu.com\" target=\"_blank\" /&gt; &lt;/map&gt; 使用Dreamweaver制作热点会变得非常的容易，最终会形成上面的代码，具体的操作，可以参考视频，http://www.chuanke.com/3885380-190205.html。 border-radius（H5） 12345678910111213 .disc&#123; width:100px; height:100px; background-color:dimgray; border-radius: 50%; cursor: pointer; position: absolute; left:50px; top:50px; line-height: 100px; text-align: center; color: white; &#125; 纯js实现需要求一个点在不在圆上简单算法、获取鼠标坐标等等|AB|=Math.abs(Math.sqrt(Math.pow(X2-X1),2)+Math.pow(Y2-Y1,2)))Math.abs()求绝对值Math.pow(底数,指数)Math.sqrt()求平方根 1234567891011document.onclick=function(e)&#123; var r=50;//圆的半径 var x1=100,y1=100,x2= e.clientX;y2= e.clientY; //计算鼠标点的位置与圆心的距离 var len=Math.abs(Math.sqrt(Math.pow(x2-x1,2)+Math.pow(y2-y1,2))); if(len&lt;=50)&#123; console.log(\"内\") &#125;else&#123; console.log(\"外\") &#125; &#125; 18.实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。12345#line&#123; width: 1000px; height:1px; background-color: #3ecdb5;&#125; &lt;div id=“line”&gt;&lt;/div&gt; 19.网页验证码是干嘛的，是为了解决什么安全问题？ 验证码是为了防止一些人使用软件恶意注册、发帖等行为而设的。 它的存在是为了确保登陆网站的是一个坐在电脑面前的真人，而不是一个自动登陆的软件 20.title与h1的区别、b与strong的区别、i与em的区别？ title是网站的标题；一般显示在网页的头部，在便签内； 而h1是标题：用来设置文章等的标题。是网页的内容，显示在页面中； strong逻辑字体格式化标签，表示强调，默认效果是通过字体加粗来表示语义强调 b就是字体加粗标签，没有语义强调的意思 CSS1.介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？ 由四个属性组成的外边距(margin)、内边距(padding)、边界(border)、内容区(width和height); 标准的CSS盒子模型和低端IE CSS盒子模型不同：宽高不一样 标准的css盒子模型宽高就是内容区宽高； 低端IE css盒子模型宽高 内边距﹢边界﹢内容区； 2.CSS选择符有哪些？哪些属性可以继承？ 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &gt; li） 6.后代选择器（li a） 7.通配符选择器（ * ） 8.属性选择器（a[rel = “external”]） 9.伪类选择器（a: hover, li:nth-child） 可继承的样式： font-size font-family color, text-indent; 不可继承的样式：border padding margin width height ; 优先级就近原则，同权重情况下样式定义最近者为准; 载入样式以最后载入的定位为准; 3.CSS优先级算法如何计算？ !important &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 4.CSS3新增伪类有那些？ p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 5.如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？ div居中 margin-left=auto；margin-right=auto； 居中浮动元素 外包装块float：left；position：relative；left：50%; 内部块float：left；position：relative；right：50%; 绝对定位div居中 方法一123456#element &#123; width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; margin-top: -200px; /* 高度的一半 */ margin-left: -300px; /* 宽度的一半 */&#125; 方法二12345.element &#123; width: 600px; height: 400px; position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); /* 第一个50%为width的一半，第二个50%为height的一半 */&#125; 方法三12345.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto; /* 水平和垂直都居中 */&#125; 若只设置“margin-left:auto”+“margin-right:auto”,则仅水平居中；若只设置“margin-top:auto”+“margin-bottom:auto”,则仅垂直居中； 方法四123456.element&#123; justify-content: center; align-items: center; /* 位于容器的中心 */ display: -webkit-flex; background: red;&#125; 6.display有哪些值？说明他们的作用。 display 的属性值有：none|inline|block|inline-block|list-item|run-in|table|inline-table|table-row-group|table-header-group|table-footer-group|table-row|table-column-group|table-column|table-cell|table-caption|inherit 其中常用的的有none、inline、block、inline-block。分别的意思是： 1、none： 元素不会显示，而且改元素现实的空间也不会保留。但有另外一个 visibility: hidden， 是保留元素的空间的。 2、inline： display的默认属性。将元素显示为内联元素，元素前后没有换行符。我们知道内联元素是无法设置宽高的，所以一旦将元素的display 属性设为 inline， 设置属性height和width是没有用的。此时影响它的高度一般是内部元素的高度（font-size）和padding。 3、block： 将元素将显示为块级元素，元素前后会带有换行符。设置为block后，元素可以设置width和height了。元素独占一行。 4、inline-block：行内块元素。这个属性值融合了inline 和 block 的特性，即是它既是内联元素，又可以设置width和height。 7.position的值relative和absolute定位原点是？ relative（相对定位）：定位原点是元素本身所在位置； absolute（绝对定位）：定位原点是离自己这一级元素最近的一级position设置为absolute或者relative的父元素的左上角为原点的 8.css3 新特性 1.CSS3的选择器 1）E:last-child 匹配父元素的最后一个子元素E。 2）E:nth-child(n)匹配父元素的第n个子元素E。 3）E:nth-last-child(n) CSS3 匹配父元素的倒数第n个子元素E。 @Font-face 特性Font-face 可以用来加载字体样式，而且它还能够加载服务器端的字体文件，让客户端显示客户端所没有安装的字体。@font-face { font-family: BorderWeb; src:url(BORDERW0.eot);}@font-face { font-family: Runic; src:url(RUNICMT0.eot);}.border { FONT-SIZE: 35px; COLOR: black; FONT-FAMILY: “BorderWeb” }.event { FONT-SIZE: 110px; COLOR: black; FONT-FAMILY: “Runic” }淘宝网字体使用 [css] view plain copy 1234@font-face &#123; font-family: iconfont; src: url(//at.alicdn.com/t/font_1465189805_4518812.eot); &#125; 3.圆角border{border-radius:15px;}4.多列布局 （multi-column layout） 1234567891011121314&lt;div class=\"mul-col\"&gt; &lt;div&gt; &lt;h3&gt;新手上路&lt;/h3&gt; &lt;p&gt;新手专区 消费警示 交易安全 24小时在线帮助 免费开店&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;付款方式&lt;/h3&gt; &lt;p&gt;快捷支付 信用卡 余额宝 蚂蚁花呗 货到付款&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;淘宝特色&lt;/h3&gt; &lt;p&gt;手机淘宝 旺信 大众评审 B格指南&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 12345678.mul-col&#123; column-count: 3; column-gap: 5px; column-rule: 1px solid gray; border-radius: 5px; border:1px solid gray; padding: 10px ; &#125; 5.阴影（Shadow） 1.css&#123;text-shadow:5px 2px 6px rgba(64, 64, 64, 0.5);&#125; 6.渐变 1background-image:-webkit-gradient(linear,0% 0%,100% 0%,from(#2A8BBE),to(#FE280E)); 7.css弹性盒子模型 123456&lt;div class=\"boxcontainer\"&gt; &lt;div class=\"item\"&gt;1&lt;/div&gt; &lt;div class=\"item\"&gt;2&lt;/div&gt; &lt;div class=\"item\"&gt;3&lt;/div&gt; &lt;div class=\"item\"&gt;4&lt;/div&gt; &lt;/div&gt; 12345678910111213141516 .boxcontainer &#123; width: 1000px; display: -webkit-box; display: -moz-box; -webkit-box-orient: horizontal; -moz-box-orient: horizontal; &#125; .item &#123; background: #357c96; font-weight: bold; margin: 2px; padding: 20px; color: #fff; font-family: Arial, sans-serif; &#125; 8.CSS3制作特效 1) Transition 对象变换时的过渡效果 transition-property 对象参与过渡的属性 transition-duration 过渡的持续时间 transition-timing-function 过渡的类型 transition-delay 延迟过渡的时间 缩写方式： transition:border-color .5s ease-in .1s, background-color .5s ease-in .1s, color .5s ease-in .1s; 拆分方式： transition-property:border-color, background-color, color; transition-duration:.5s, .5s, .5s; transition-timing-function:ease-in, ease-in, ease-in; transition-delay:.1s, .1s, .1s; 示例代码： 1234567891011 .main&#123; position: relative; margin: 0 auto; height:45px; width: 300px; background-color:lightgray; transition:background-color .6s ease-in 0s; &#125; .main:hover&#123; background-color: dimgray; &#125; 2) Transform 2D转换效果 主要包括 translate（水平移动）、rotate（旋转）、scale（伸缩）、skew（倾斜） 12345678910111213 .main&#123; position: relative; top:200px; margin: 0 auto; height:45px; width: 300px; background-color:dimgray; transition:transform .6s ease 0s; transform: rotate(0deg); &#125; .main:hover&#123; transform: rotate(180deg); &#125; 3) Animation动画特效123456789101112131415161718192021222324252627.main&#123; position: absolute; left: 10px; top:200px; height:45px; width: 300px; background-color:cadetblue; &#125; .main:hover&#123; animation: animations 2s ease 0s; &#125; @keyframes animations &#123; 0%&#123; left: 10px; opacity: 1; &#125; 50%,70%&#123; left: 50%; opacity: .7; margin-left:-150px; &#125; 100%&#123; left: 100%; opacity: 0; margin-left:-300px; &#125; &#125; 9.请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？ 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。 采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。 在布局上有了比以前更加灵活的空间。 具体：http://www.w3cplus.com/css3/flexbox-basics.html 10.用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） 1234567.demo &#123; width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent;&#125; 11.一个满屏 品 字布局 如何设计? 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 12.常见兼容性问题？ png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. 浏览器默认的margin和padding不同。解决方案是加一个全局的{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——display:inline;将其转化为行内属性。(这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。123456.bb&#123; background-color:red;/所有识别/ background-color:#00deff\\9; /IE6、7、8识别/ +background-color:#a200ff;/IE6、7识别/ _background-color:#1e0bd1;/IE6识别/&#125; IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。 IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} 13.li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 14.为什么要初始化CSS样式。 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法： {padding: 0; margin: 0;} （强烈不建议） 淘宝的样式初始化代码： body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } body, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; } h1, h2, h3, h4, h5, h6{ font-size:100%; } address, cite, dfn, em, var { font-style:normal; } code, kbd, pre, samp { font-family:couriernew, courier, monospace; } small{ font-size:12px; } ul, ol { list-style:none; } a { text-decoration:none; } a:hover { text-decoration:underline; } sup { vertical-align:text-top; } sub{ vertical-align:text-bottom; } legend { color:#000; } fieldset, img { border:0; } button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } 15.absolute的containing block计算方式跟正常流有什么不同？ 无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断： 1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 2、否则,则由这个祖先元素的 padding box 构成。 如果都找不到，则为 initial containing block。 补充： static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） absolute: 向上找最近的定位为absolute/relative的元素 fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block 16.CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ 对于一般的元素，它的表现跟display:hidden是一样的。 但例外的是，如果这个元素是table相关的元素，例如table行，table group，table列，table column group，它的表现却跟display: none一样，也就是说，它们占用的空间也会释放。 在谷歌浏览器里，使用collapse值和使用hidden值没有什么区别。 在火狐浏览器、Opera和IE11里，使用collapse值的效果就如它的字面意思：table的行会消失，它的下面一行会补充它的位置。 17.position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ position控制元素是否在文档流中，static和relative都存在于文档流，fixed直接脱离文档流锁定在以整个文档为offsetParent的位置，而absolute也是直接脱离文档流锁定在最近的一个有position属性的parent的位置上。display控制布局方式，block以block方式布局，inline以inline方式布局，inline-block以inline-block方式布局，而所有的布局方式的前提是元素在文档流当中，所以如果position设置为脱离文档流，display就只影响子元素的布局了。display:none直接让元素脱离文档流一样的布局方式。margin collapse也是在文档流时才会有效。overflow指的是当超出布局边界时的显示效果，跟怎么布局没关系。float也是直接脱离文档流了。 http://www.cnblogs.com/jackyWHJ/p/3756087.html 18.对BFC规范(块级格式化上下文：block formatting context)的理解？ （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。） 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。 19.CSS权重优先级是如何计算的？ 1.第一等：代表内联样式，如: style=””，权值为1000。 2.第二等：代表ID选择器，如：#content，权值为0100。 3.第三等：代表类，伪类和属性选择器，如.content，权值为0010。 4.第四等：代表类型选择器和伪元素选择器，如div p，权值为0001。 5.通配符、子选择器、相邻选择器等的。如*、&gt;、+,权值为0000。 6.继承的样式没有权值。 比较规则 1,0,0,0 &gt; 0,99,99,99。也就是说从左往右逐个等级比较，前一等级相等才往后比。 无论是行间、内部和外部样式，都是按照这个规则来进行比较。而不是直观的行间&gt;内部&gt;外部样式；ID&gt;class&gt;元素。之所以有这样的错觉，是因为确实行间为第一等的权重，所以它的权重是最高的。而内部样式可能一般写在了外部样式引用了之后，所以覆盖掉了之前的。 在权重相同的情况下，后面的样式会覆盖掉前面的样式。 通配符、子选择器、相邻选择器等的。虽然权值为0000，但是也比继承的样式优先。 20.请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式 清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。 1、父级div定义height； 2、父级div 也一起浮动； 3、常规的使用一个class；12345678910.clearfix:before, .clearfix:after &#123; content: \" \"; display: table;&#125;.clearfix:after &#123; clear: both;&#125;.clearfix &#123; *zoom: 1;&#125; 4、SASS编译的时候，浮动元素的父级div定义伪类:after1234567&amp;:after,&amp;:before&#123; content: \" \"; visibility: hidden; display: block; height: 0; clear: both;&#125; 解析原理： 1) display:block 使生成的元素以块级元素显示,占满剩余空间; 2) height:0 避免生成内容破坏原有布局的高度。 3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 4）通过 content:”.”生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:”.”,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”” 仍然会产生额外的空隙； 5）zoom：1 触发IE hasLayout。 通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。 zoom:1的清楚浮动原理? 清楚浮动，触发hasLayout； Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。 譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。 来龙去脉大概如下： 当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。 Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。 21.移动端的布局用过媒体查询吗？ 假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } 22.使用 CSS 预处理器吗？喜欢那个？ SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS) 23.CSS优化、提高性能的方法有哪些？ 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 24.浏览器是怎样解析CSS选择器的？ 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。 只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 25.在网页中的应该使用奇数还是偶数的字体？为什么呢？ 偶数字号相对更容易和 web 设计的其他部分构成比例关系。比如：当我用了 14 px 的正文字号，我可能会在一些地方用 14 × 0.5 = 7 px 的 margin，在另一些地方用 14 × 1.5 = 21 px 的标题字号。Windows 自带的点阵宋体（中易宋体）从 Vista 开始只提供 12、14、16 px 这三个大小的点阵，而 13、15、17 px 时用的是小一号的点阵（即每个字占的空间大了 1 px，但点阵没变），于是略显稀疏。这个我不确定，需要确认：听说有不少字体的 hinting 都只专门处理了常用的几个偶数字号。除了上面说的这些，奇偶字号的字体渲染效果似乎其实差别不大（尤其在 OS X 和 Linux 以及手持设备上）。即使在 Windows 里，微软雅黑在 11 至 17 px 之间的奇偶字号效果似乎也都差不多。（呃，都差不多糟糕……）目前 12、13、14、15、16 px 其实都是很不错的正文字号。知乎和豆瓣的正文字号都是 13 px，而中文维基百科的正文字号是 15 px，并没有什么不好。 26.margin和padding分别适合什么场景使用？ margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。 margin用于布局分开元素使元素与元素互不相干； padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段 27.抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题] 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议） body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } body, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; } h1, h2, h3, h4, h5, h6{ font-size:100%; } address, cite, dfn, em, var { font-style:normal; } code, kbd, pre, samp { font-family:couriernew, courier, monospace; } small{ font-size:12px; } ul, ol { list-style:none; } a { text-decoration:none; } a:hover { text-decoration:underline; } sup { vertical-align:text-top; } sub{ vertical-align:text-bottom; } legend { color:#000; } fieldset, img { border:0; } button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } 28.元素竖向的百分比设定是相对于容器的高度吗？ 相对于父元素宽度的： [max/min-]width、left、right、padding、margin 等； 相对于父元素高度的： [max/min-]height、top、bottom 等； 相对于继承字号的： font-size 等； 相对于自身字号的： line-height 等； 相对于自身宽高的： border-radius、background-size、transform: translate()、transform-origin、zoom、clip-path 等； 特殊算法的： background-position（方向长度 / 该方向除背景图之外部分总长度 * 100）、 filter 系列函数等； 29.全屏滚动的原理是什么？用到了CSS的那些属性？ 30.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 响应式网站设计(Responsive Web design)的理念是：集中创建页面的图片排版大小，可以智能地根据用户行为以及使用的设备环境（系统平台、屏幕尺寸、屏幕定向等）进行相对应的布局。 基本原理: 媒体查询 @media 兼容IE可以使用JS辅助一下来解决 31.视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？） 当滚动鼠标滚轮的时候，各图层以不同速度移动，形成视差的效果。这就是时差滚动的大致原理。原理是这样，但落实到技术细节上时，实现的方法却各种各样。我个人大致归纳了一下：1、以 “页面滚动条” 作为 “视差动画进度条” 的；2、以 “滚轮刻度” 当作 “动画帧度” 去播放动画的（或者直接称为“隐藏进度条”）；3、鉴听mousewheel事件，事件被触发即播放动画，实现“翻页”效果；下面的回答，均以上述1类的实现方式为基准。 32.::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成） 双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法， 比如:first-line、:first-letter、:before、:after等， 而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。 想让插入的内容出现在其它内容前，使用::before，否者，使用::after； 在代码顺序上，::after生成的内容也比::before生成的内容靠后。 如果按堆栈视角，::after生成的内容会在::before生成的内容之上 33.如何修改chrome记住密码后自动填充表单的黄色背景 ？12345input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill &#123;background-color: rgb(250, 255, 189); / #FAFFBD; /background-image: none;color: rgb(0, 0, 0);&#125; 34.你对line-height是如何理解的？ 凡是有inline-block元素的地方就会有line-height的存在，就算你不设它的值，line-height依然通过继承来的fontsize等属性获得与之相匹配的line-height，这也是许多inline-block元素使用过程中出现各种怪现象的原因 35.设置元素浮动后，该元素的display值是多少？（自动变成display:block） 自动变成了 display:block 36.怎么让Chrome支持小于12px 的文字？ 1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。 3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。 4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。 35.让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;） -webkit-font-smoothing控制的字体渲染只对MacOS的Webkit有效。 所以，你在MacOS测试环境下面设置-webkit-font-smoothing时，只要你不把它设置为none，怎么好看就设置为什么属性，反正这个属性仅仅是面向MacOS，不会在其他上下文中出岔子的（除了none的情形）。 前端控制字体渲染的接口非常匮乏，如果可能，尽可能地控制输出的字体，而非控制字体渲染比较好。 以下测试则会表明，-webkit-font-smoothing在MacOS上才有效果。 Windows 测试环境: Win7 Pro + Chrome（请戳大图）： 结论：Windows系统上-webkit-font-smoothing属性不造成区别。 iOS 测试环境:iPad Air + iOS7 + Safari（请戳大图） （iOS上没有Hiragino Sans GB，不要被标题误导了……） 结论：iOS上，修改-webkit-font-smoothing属性，结果是： -webkit-font-smoothing: none: 无抗锯齿 -webkit-font-smoothing: antialiased | subpixel-antialiased | default: 灰度平滑 MacOS 测试环境：MBP + Safari（请戳大图） 结论：iOS上，修改-webkit-font-smoothing属性，结果是： -webkit-font-smoothing: none: 无抗锯齿 -webkit-font-smoothing: subpixel-antialiased | default: 次像素平滑 -webkit-font-smoothing: antialiased: 灰度平滑 字体抗锯齿技术可以分为如下几类： 黑白渲染：现在已经绝迹 灰度渲染：常用于Android和iOS等移动设备的 次像素平滑：常见于Mac OS和MacType For Windows ClearType：黑白渲染和次像素平滑的折中。WinXP内置，默认关闭；Win7以上默认打开 理想形状；黑白渲染；灰度渲染。 次像素平滑技术原理，从右往左看，注意到一个pixel里的渐变。 36.font-style属性可以让它赋值为“oblique” oblique是什么意思？ font-style: oblique 选择字体族的 oblique 变体。italic 选择字体族的 italic 变体，如果没有 italic 变体就妥协到 oblique 变体。如果字体族连 oblique 也未提供，则由浏览器合成倾斜的仿 oblique。比如 font-family: Georgia, serif 时，指定 font-style: italic，则浏览器使用 Georgia Italic。若 font-family: Microsoft YaHei, sans-serif 时指定 font-style: italic，因为微软雅黑没有 italic 或 oblique 变体，浏览器只得将 regular 变体倾斜以自动合成仿 oblique。没有什么应当使用 oblique 的场景。如果你读完以上那些文档还不知道字体的 oblique 和 italic 分别是什么意思，读：既然浏览器能用算法将正常字体加粗和变斜，那么斜体有必要吗？CSS 里没有「oblique 字体和 italic 字体」。CSS 里只有 font-style 这么一个属性以及该属性的 oblique。没有什么应当使用e 和 italic 等取值，这些取值要求浏览器选取相应的字体。理清逻辑。 37.position:fixed;在android下无效怎么处理？ &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt; 38.如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 39.display:inline-block 什么时候会显示间隙？(携程) 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 40.overflow: scroll时不能平滑滚动的问题怎么处理？ 1、阻止所有能导致页面滚动的事件。//scroll不能阻止，只能阻止mousewheel，鼠标拽滚动条就悲剧了； 2、bodyoverflow:hidden//win下右侧滚动条会消失导致页面横移，移动端阻止不了； 3、把滚动部分单独放在一个div里，和弹出部分同级，body和window同高。//所有涉及offset/scrollTop的方法都要修改。fix并且width100%的元素(比如微博顶栏)会压在内容区滚动条上； 4、弹出时算scrollTop，给内容区fix然后top移动到目前位置，同时body给一个overflow-y:scroll强撑出滚动条。 41.有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。 12345678910111213141516171819 &lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"gb2312\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; body &#123; height: 100%; padding: 0; margin: 0; &#125; .box &#123; height: 400px; position: relative; &#125; .a &#123; height: 100px; background: #ff0000; &#125; .b &#123; background: #00ff00; width: 100%; position: absolute; top: 100px ; left: 0 ; bottom: 0;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"a\"&gt;&lt;/div&gt; &lt;div class=\"b\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 42.png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？ PNG：这是三种中质量最好的一种，保存图像是静态图，可以保留32位色，也能保留透明与半透明区域，如果你是位图像设计者，要保存一幅自己设计的并且只有一个图层的图，建议你选择Png，但是很多网站不支持PNG上传 JPG：这是目前使用最广泛的格式之一，因为其高质量的压缩率导致的图片大小减少，而且也支持32位色彩，因此被广泛使用，一般情况下，任何支持图片的地方都支持jpg，也为静态图，但确点是不支持透明区域 GIF：这也是目前使用最广泛的格式之一，和jpg相比，有以下不同：颜色数只支持256色，支持透明区域，不支持半透明区域，可以保存为动态图 WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。 43.什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做） 传感器是一种检测装置，能感受到被测量的信息，并能将感受到的信息，按一定规律变换成为电信号或其他所需形式的信息输出，以满足信息的传输、处理、存储、显示、记录和控制等要求。 传感器的特点包括:微型化、数字化、单伐厕和丿古搽汰敞咯智能化、多功能化、系统化、网络化。它是实现自动检测和自动控制的首要环节。传感器的存在和发展，让物体有了触觉、味觉和嗅觉等感官，让物体慢慢变得活了起来。通常根据其基本感知功能分为热敏元件、光敏元件、气敏元件、力敏元件、磁敏元件、湿敏元件、声敏元件、放射线敏感元件、色敏元件和味敏元件等十大类。 44.style标签写在body后与body前有什么区别？ 写在body标签后由于浏览器以逐行方式对html文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题） 45.css实现各种圆角圆形：CSS代码如下：12345678#circle &#123; width: 100px; height: 100px; background: red; -moz-border-radius: 50px; -webkit-border-radius: 50px; border-radius: 50px; &#125; 椭圆：CSS代码12345678#oval &#123; width: 200px; height: 100px; background: red; -moz-border-radius: 100px / 50px; -webkit-border-radius: 100px / 50px; border-radius: 100px / 50px;&#125; 倒三角：css代码1234567#retangle&#123; width: 0; height: 0; border-left:50px solid transparent; border-right:50px solid transparent; border-top: 100px solid yellow;&#125; 正三角：css代码1234567#back_retangle&#123; width: 0; height: 0; border-right: solid 50px transparent; border-left: solid 50px transparent; border-bottom: 50px solid black;&#125; JavaScript1.介绍JavaScript的基本数据类型。 Undefined、Null、Boolean、Number、String ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 ) 2.说说写JavaScript的基本规范？ 文件编码统一为utf-8； 2. 书写过程过, 每行代码结束必须有分号； 3. 库引入: 原则上仅引入jQuery库； 4. 变量命名: 以下划线链接每个单词，类型_变量名； s：表示字符串； n：表示数字； b：表示逻辑； a：表示数组； r：表示正则表达式； f：表示函数； o：表示以上未涉及到的其他对象； 变量在作用域的顶部申明。 5.常量：全部大写，以下划线分隔 如网站的URL，域,图片目录路径，js和css用到的目录路径； 6. 类命名: 首字母大写, 驼峰式命名. 如 Comment; 7. 函数命名: 首字母小写驼峰式命名. 如getUserName(); 8.类中私有方法，以下划线+方法名标注,私有方法不能在类外被调用。 9. 命名语义化, 尽可能利用英文单词或其缩写； 10. 代码结构明了化, 加适量注释. 提高函数重用率； 1)大功能区块的功能描述(类，函数)/ 功能描述 参数描述 返回值 / 2)单行的注释(放在行末尾) //注释 11. 注重与html分离, 减小reflow, 注重性能. 12.Dom中自定义的class，以j_classname的形式 13.把外部JavaScript文件放在HTML底部,的前面 14.优化循环(循环体中若有Dom操作，应该把Dom操作提到循环体外；在同一作用域内，Dom选择赋值给一局部变量。) 15.单引号和双引号 为了避免混乱，我们建议在HTML中使用双引号，在JavaScript中使用单引号。 3.JavaScript原型，原型链 ? 有什么特点？ 原型：我们创建的每个函数都有一个prototype（原型）属性。这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。 原型链：​用来继承和共享属性的对象组成的(有限的)对象链。 ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。 只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型。 不能用字面量创建原型的方法，这样做会重写原型链。 不要在原型对象中定义属性的，否则会被所有实例共享。 4.JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？ 数据类型是所有程序都会涉及到的，是计算机语言比较基础知识，这种问题被问到的可能性其实并不大，这样的题目只要花点时间把它记下来就好了，难易程度一般。 两大类： 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 区别： 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其 在栈中的地址，取得地址后从堆中获得实体 5.Javascript如何实现继承？ 1、原型链继承 核心： 将父类的实例作为子类的原型123456789101112 function Cat()&#123; &#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.eat('fish'));console.log(cat.sleep());console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 2、构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）1234567891011 function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 3、实例继承 核心：为父类实例添加新特性，作为子类实例返回123456789101112 function Cat(name)&#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 4.拷贝继承1234567891011121314 function Cat(name)&#123; var animal = new Animal(); for(var p in animal)&#123; Cat.prototype[p] = animal[p]; &#125; Cat.prototype.name = name || 'Tom';&#125;// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 5、组合继承123456789101112 function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 6、寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点123456789101112131415161718 function Cat(name)&#123; Animal.call(this); this.name = name || 'Tom';&#125;(function()&#123; // 创建一个没有实例方法的类 var Super = function()&#123;&#125;; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();&#125;)();// Test Codevar cat = new Cat();console.log(cat.name);console.log(cat.sleep());console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 6.Javascript创建对象的几种方式？ // 1. 工厂方法:能创建并返回特定类型对象的工厂函数(factory function). function createCar(sColor){ var car = new Object(); // 或者 var car = new Object ; // 对象属性 car.color = sColor ; // 对象方法 car.showColor = function (){ alert(123); } ; // 记住，这里一定要用 ; 表示结束 return car; // 这里是 return car ; 而不是 return this.car ; 因为 this.car 为 undefined } /* 调用此函数时，将创建对象，并赋予它所有必要的属性，使用此方法创建 car 对象的两个版本， ( oCar1 和 oCar2 ) ,他们的属性完全一样。 使用此方法存在的问题: 语义上看起来不像使用带有构造函数的 new 运算那么正规. 使用这种方式必须创建对象的方法。每次调用 createCar()，都要创建 showColor(),意味着每一个对象都有自己的 showColor 版本，事实上，每一个对象都共享了是同一个函数.有些开发者在工厂函数外定义对象的方法，然后通过属性指向该方法。从而避免这个问题:*/function createCar2(sColor){var car = new Object();car.color = sColor ;car.showColor = showColor ; return car ;} function showColor(){alert(this.color);} var oCar1 = createCar(‘red’);var oCar2 = createCar(‘yellow’); var oCar3 = createCar2(‘blue’);var oCar4 = createCar2(‘black’); /注意这两个对象(oCar3 和 oCar4 ) 调用showColor 属性的方式，虽然美其名曰是“属性”，其实还是方法!!!所以是 oCar3.showColor(); 而不是 oCar3.showColor ; / oCar3.showColor();oCar4.showColor(); /*在这段重写的代码中，在函数 createCar2() 前定义了函数showColor(), 在 createCar2() 内部，赋予对象一个已经指向已经存在的 showColor() 函数的指针，从功能上讲，这样解决了重复创建对象的问题，但该函数看起来不像对象的方法。 所有这些问题引起了开发者的定义构造函数的出现*/ // 2. 构造函数方式 function Car(sColor){ this.color = sColor; this.showColor = function(){ alert(this.color); }; } var car1 = new Car(‘red’); car1.showColor(); /你可能已经注意到第一个的差别了，在构造函数内部无创建对象，而是使用 this 关键字，使用 new运算符调用构造函数，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值，（不必明确使用 return 运算符）。这种方式在管理函数方面与工厂方法一样都存在相同的问题. / // 3. 原型方式function PCar(){} PCar.prototype.color = “blue”;var pcar1 = new PCar(); /调用 new Car()时，原型的所有属性都被立即赋予要创建的对象，意味着所有的 PCar 实例存放的是指向showColor() 函数的指针，从语义看起来都属于一个对象，因此解决了前面两种方式存在的问题。此外使用该方法，还能使用 instanceof 运算符检查给定变量指向的对象类型。因此下面的代码将输出 true: /alert(pcar1 instanceof PCar); // output “true” /*这个方法看起来不错，遗憾的是，它并不尽人意。 首先这个构造函数没有参数。使用原型方式时，不能给构造函数传递参数初始化属性值，因为 pcar1 和pcar2 的属性都等于 “blue” 真正的问题出现在属性指向的对象,而不是函数时，函数共享不会造成任何问题，但是对象却是很少被多个实例共享的。*/ // 4. 混合的构造函数/原型方式(推荐)/联合使用构造函数和原型方式，就可像使用其他程序设计语言一样创建对象，这种概念非常简单，即用构造函数定义对象的所有非函数属性，用原型方式定义对象的函数属性(方法)。 / function hCar(sColor){this.color = sColor;this.drivers = new Array(‘Mike’,’Sue’);} hCar.prototype.showColor = function(){alert(this.color);} var hcar1 = new hCar(‘y color’);var hcar2 = new hCar(‘r color’); hcar1.drivers.push(‘Matt’); alert(hcar1.drivers); // output “Mike,Sue,Matt”alert(hcar2.drivers); // output “Mike,Sue” // 5. 动态原型方式 (推荐)/*对于习惯使用其他开发语言的开发者来说，使用混合构造函数/原型方式感觉不那么和谐。批评构造函数/原型方式的人认为，在构造函数内找属性，在外部找方法的做法不合理。所以他们设计了动态原型方式，以供更友好的编码风格。 动态原型方式的基本想法与混合构造函数/原型方式 相同，即在构造函数内定义非函数的属性，而函数的属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。下面是使用动态原型方法重写的 Car 类:*/ function DCar(sColor){this.color = sColor;this.drivers = new Array(‘Mike’,’Sue’); if(typeof DCar._initialized == ‘undefined’){ DCar.prototype.showColor = function(){alert(this.color);}} DCar._initialized = true;} var dcar1 = new DCar(‘y dcar’);var dcar2 = new DCar(‘b dcar’); dcar1.showColor();dcar2.showColor(); alert(DCar._initialized); // output “true”alert(dcar1._initialized); // output “undefined”// 6、对象直接量、new创建创建对象最简单的方法是你的javascript代码中包含对象直接量，也可以通过运算符new创建。var empty = {}; // An object with no propertiesvar point = { x:0, y:0 };var circle = { x:point.x, y:point.y+1, radius:2 };var homer = {“name”: “Homer Simpson”,“age”: 34,“married”: true,“occupation”: “plant operator”,‘email’: homer@example.com};var a = new Array(); // Create an empty arrayvar d = new Date(); // Create an object representing the current date and timevar r = new RegExp(“javascript”, “i”); // Create a pattern-matching object 创建对象后，我们可以通过”.”运算符，在对象中创建新属性、引用已有属性、设置属性值等。 var book = new Object(); //创建对象 book.title=”JavaScript: The Definitive Guide”; book.chapter1=new Object(); //作为对象属性的，嵌套对象 book.chapter1.title = “Introduction to JavaScript”; book.chapter1.pages = 11; book.chapter2 = { title: “Lexical Structure”, pages: 6 };alert(“Outline: “ + book.title + “\\n\\t” + “Chapter 1 “ + book.chapter1.title + “\\n\\t” + “Chapter 2 “ + book.chapter2.title); // 从对象中读取一些属性.在上例中，需注意，可以通过把一个值赋给对象的一个新属性来创建它． 在JavaScript语句中提到过用for/in语句可以遍历对象的属性和方法。 7.Javascript作用链域? 作用域就是变量和函数的可访问范围，控制着变量和函数的可见性与生命周期，在JavaScript中变量的作用域有全局作用域和局部作用域。 单纯的JavaScript作用域还是很好理解的，在一些类C编程语言中花括号内的每一段代码都有各自的作用域，而且变量在声明它们的代码段外是不可见的，称之为块级的作用域，JavaScript容易让初学者误会的地方也在于此，JavaScript并没有块及的作用域，只有函数级作用域：变量在声明它们的函数体及其子函数内是可见的。 变量没有在函数内声明或者声明的时候没有带var就是全局变量，拥有全局作用域，window对象的所有属性拥有全局作用域；在代码任何地方都可以访问，函数内部声明并且以var修饰的变量就是局部变量，只能在函数体内使用，函数的参数虽然没有使用var但仍然是局部变量。 8.谈谈This对象的理解。 this表示当前对象，this的指向是根据调用的上下文来决定的，默认指向window对象，指向window对象时可以省略不写，例如： this.alert() &lt;=&gt; window.alert()&lt;=&gt; alert(); 调用的上下文环境包括全局和局部 全局环境 全局环境就是在里面，这里的this始终指向的是window对象 局部环境 1）在全局作用域下直接调用函数，this指向window 1234 function func()&#123; console.log(this) ;//this指向的还是window对象 &#125; func(); 2）对象函数调用，哪个对象调用就指向哪个对象 123456&lt;input type=\"button\"id=\"btnOK\" value=\"OK\"&gt; varbtnOK=document.getElementById(\"btnOK\"); btnOK.onclick=function()&#123; console.log(this);//this指向的是btnOK对象 &#125; 3）使用 new 实例化对象，在构造函数中的this指向实例化对象。 1234 var Show=function()&#123; this.myName=\"Mr.Cao\"; //这里的this指向的是obj对象 &#125; var obj=new Show(); 4）使用call或apply改变this的指向 12345678var Go=function()&#123; this.address=\"深圳\"; &#125; var Show=function()&#123; console.log(this.address);//输出 深圳 &#125; var go=new Go(); Show.call(go);//改变Show方法的this指向go对象 加分项 1. 用于区分全局变量和局部变量，需要使用this 1234var age=20; function show(age)&#123; this.age=age; &#125; 2.返回函数当前的对象，看jquery1.8.3源码. 3.将当前的对象传递到下一个函数，看jquery1.8.3源码。 8.eval是做什么的？ eval()的作用 把字符串参数解析成JS代码并运行，并返回执行的结果；123 eval(\"2+3\");//执行加运算，并返回运算值。 eval(\"varage=10\");//声明一个age变量 eval的作用域123456functiona()&#123; eval(\"var x=1\"); //等效于 var x=1; console.log(x); //输出1 &#125; a(); console.log(x);//错误 x没有定义 注意事项 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 其它作用 由JSON字符串转换为JSON对象的时候可以用eval，例如：123var json=\"&#123;name:'Mr.CAO',age:30&#125;\"; var jsonObj=eval(\"(\"+json+\")\"); console.log(jsonObj); 9.什么是window对象? 什么是document对象? 简单来说，document是window的一个对象属性。 Window 对象表示浏览器中打开的窗口。 如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 所有的全局函数和对象都属于Window 对象的属性和方法。 document 对 Document 对象的只读引用。 [window对象] 它是一个顶层对象,而不是另一个对象的属性，即浏览器的窗口。 属性 defaultStatus 缺省的状态条消息 document 当前显示的文档(该属性本身也是一个对象) frame 窗口里的一个框架((FRAME&gt;)(该属性本身也是一个对象) frames array 列举窗口的框架对象的数组,按照这些对象在文档中出现的顺序列出( 该属性本身也是一个 对象) history 窗口的历史列表(该属性本身也是一个对象) length 窗口内的框架数 location 窗口所显示文档的完整(绝对)URL(该属性本身也是一个对象)不要把它与如document.location 混淆,后者是当前显示文档的URL。用户可以改变window.location(用另一个文档取代当前文档),但却不能改变 document.location (因为这是当前显示文档的位置) name 窗口打开时,赋予该窗口的名字 opener 代表使用window.open打开当前窗口的脚本所在的窗口(这是Netscape Navigator 3.0beta 3所引 入的一个新属性) parent 包含当前框架的窗口的同义词。frame和window对象的一个属性 self 当前窗口或框架的同义词 status 状态条中的消息 top 包含当前框架的最顶层浏览器窗口的同义词 window 当前窗口或框架的同义词,与self相同 方法 alert() 打开一个Alert消息框 clearTimeout() 用来终止setTimeout方法的工作 close() 关闭窗口 confirm() 打开一个Confirm消息框,用户可以选择OK或Cancel,如果用户单击OK,该方法返回true,单击 Cancel返回false blur() 把焦点从指定窗口移开(这是Netscape Navigator 3.0 beta 3引入的新方法) focus() 把指定的窗口带到前台(另一个新方法) open() 打开一个新窗口 prompt() 打开一个Prompt对话框,用户可向该框键入文本,并把键入的文本返回到脚本 setTimeout() 等待一段指定的毫秒数时间,然后运行指令事件处理程序事件处理程序 Onload() 页面载入时触发 Onunload() 页面关闭时触发 [document 对象] 该对象是window和frames对象的一个属性,是显示于窗口或框架内的一个文档。 属性 alinkColor 活动链接的颜色(ALINK) anchor 一个HTMI锚点,使用标记创建(该属性本身也是一个对象) anchors array 列出文档锚点对象的数组()(该属性本身也是一个对象) bgColor 文档的背景颜色(BGCOLOR) cookie 存储于cookie.txt文件内的一段信息,它是该文档对象的一个属性 fgColor 文档的文本颜色(标记里的TEXT特性) form 文档中的一个窗体()(该属性本身也是一个对象) forms anay 按照其出现在文档中的顺序列出窗体对象的一个数组(该属性本身也是一个对象) lastModified 文档最后的修改日期 linkColor 文档的链接的颜色,即标记中的LINK特性(链接到用户没有观察到的文档) link 文档中的一个标记(该属性本身也是一个对象) links array 文档中link对象的一个数组,按照它们出现在文档中的顺序排列(该属性本身也是一个对象) location 当前显示文档的URL。用户不能改变document.location(因为这是当前显示文档的位置)。但是, 可以改变 window.location (用其它文档取代当前文档)window.location本身也是一个对象,而 document.location不是对象 referrer 包含链接的文档的URL,用户单击该链接可到达当前文档 title 文档的标题((TITLE&gt;) vlinkColor 指向用户已观察过的文档的链接文本颜色,即标记的VLINK特性 方法 clear 清除指定文档的内容 close 关闭文档流 open 打开文档流 write 把文本写入文档 writeln 把文本写入文档,并以换行符结尾 区别:1、window 指窗体。document指页面。document是window的一个子对象。 2、用户不能改变 document.location(因为这是当前显示文档的位置)。但是,可以改变window.location (用其它文档取代当前文档)window.location本身也是一个对象,而document.location不是对象 10.null，undefined的区别？ 在JavaScript中存在这样两种原始类型:Null与Undefined。这两种类型常常会使JavaScript的开发人员产生疑惑，在什么时候是Null，什么时候又是Undefined? Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。 Null类型也只有一个值，即null。null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 11.写一个通用的事件侦听器函数(机试题)。 12.[“1”, “2”, “3”].map(parseInt) 答案是多少？ 答案[1, NaN, NaN]. 原因：parseInt接收的是两个参数，map传递的是3个参数。 13.关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？1234567891011 function stopEvent()&#123; //阻止冒泡事件 //取消事件冒泡 var e=arguments.callee.caller.arguments[0]||event; //若省略此句，下面的e改为event，IE运行可以，但是其他浏览器就不兼容 if (e &amp;&amp; e.stopPropagation) &#123; // this code is for Mozilla and Opera e.stopPropagation(); &#125; else if (window.event) &#123; // this code is for IE window.event.cancelBubble = true; &#125; &#125; 一般在IE环境下可以省略掉（var e=arguments.callee.caller.arguments[0]||event;）直接运行即可，但是在FF下不行了，它会报e.stopPropagation没有定义，所以要事先定义，才能兼容。 14.什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 闭包的特性： 1.函数内再嵌套函数 2.内部函数可以引用外层的参数和变量 3.参数和变量不会被垃圾回收机制回收 15.javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 标记 严格模式后 其一：如果在语法检测时发现语法问题，则整个代码块失效，并导致一个语法异常。 其二：如果在运行期出现了违反严格模式的代码，则抛出执行异常。 注：经过测试IE6,7,8,9均不支持严格模式。 缺点： 现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 16.如何判断一个对象是否属于某个类？ 如何判断js中的数据类型：typeof、instanceof、 constructor、 prototype方法比较 遇到预知Object类型的情况可以选用instanceof或constructor方法 17.new操作符具体干了什么呢?（1）创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。（2）属性和方法被加入到 this 引用的对象中。（3）新创建的对象由 this 所引用，并且最后隐式的返回 this 。 18.对JSON的了解？ JSON的全称是”JavaScript Object Notation”，意思是JavaScript对象表示法，它是一种基于文本，独立于语言的轻量级数据交换格式。XML也是一种数据交换格式，为什么没有选择XML呢？因为XML虽然可以作为跨平台的数据交换格式，但是在JS(JavaScript的简写)中处理XML非常不方便，同时XML标记比数据多，增加了交换产生的流量，而JSON没有附加的任何标记，在JS中可作为对象处理，所以我们更倾向于选择JSON来交换数据。这篇文章主要从以下几个方面来说明JSON。 1，JSON的两种结构 2，认识JSON字符串 3，在JS中如何使用JSON 4，在.NET中如何使用JSON 5，总结 JSON有两种表示结构，对象和数组。 对象结构以”{”大括号开始，以”}”大括号结束。中间部分由0或多个以”，”分隔的”key(关键字)/value(值)”对构成，关键字和值之间以”：”分隔，语法结构如代码。 其中关键字是字符串，而值可以是字符串，数值，true,false,null,对象或数组 数组结构以”[”开始，”]”结束。中间由0或多个以”，”分隔的值列表组成，语法结构如代码。 字符串：这个很好解释，指使用“”双引号或’’单引号包括的字符。例如：var comStr = ‘this is string’; json字符串：指的是符合json格式要求的js字符串。例如：var jsonStr = “{StudentID:’100’,Name:’tmac’,Hometown:’usa’}”; json对象：指符合json格式要求的js对象。例如：var jsonObj = { StudentID: “100”, Name: “tmac”, Hometown: “usa” }; JSON是JS的一个子集，所以可以在JS中轻松地读，写JSON。读和写JSON都有两种方法，分别是利用”.”操作符和“[key]”的方式。 19.js延迟加载的方式有哪些？ 1.使用setTimeout延迟方法的加载时间12345678function A()&#123; $.post(\"/lord/login\",&#123;name:username,pwd:password&#125;,function()&#123; alert(\"Hello\"); &#125;); &#125; $(function ()&#123; setTimeout('A()', 1000); //延迟1秒 &#125;) 2.让js最后加载 例如引入外部js脚本文件时，如果放入html的head中,则页面加载前该js脚本就会被加载入页面，而放入body中，则会按照页面从上倒下的加载顺序来运行javascript的代码~~~ 所以我们可以把js外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度 3.上述方法2也会偶尔让你收到Google页面速度测试工具的“延迟加载javascript”警告。所以这里的解决方案将是来自Google帮助页面的推荐方案。 20.Ajax 是什么? 如何创建一个Ajax？ Ajax 是一种异步请求数据的一种技术，对于改善用户的体验和程序的性能很有帮助 异步传输+js+xml 所谓异步,在这里简单的解释就是:向服务器发送请求的时候,我们不必等待结果,而是可以同时做其他的事情,等到有了结果它自己会根据设定进行后续操作,与此同时,页面是不会发送整夜刷新的,提高了用户体验. (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法,URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新 21.同步和异步的区别? 在计算机领域，同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。 22.如何解决跨域问题? 共有几种解决方案： （1）document.domain + iframe （2）动态创建script （3）window.name + iframe （4）window.postMessage （5）CORS （6）JSONP （7）nginx代理 23.谈一谈你对ECMAScript6的了解？ ES6是继ES5之后的一次主要改进，语言规范由ES5.1时代的245页扩充至600页。ES6增添了许多必要的特性，例如：模块和类，以及一些实用特性，例如Maps、Sets、Promises、生成器（Generators）等。尽管ES6做了大量的更新，但是它依旧完全向后兼容以前的版本，标准化委员会决定避免由不兼容版本语言导致的“web体验破碎”。结果是，所有老代码都可以正常运行，整个过渡也显得更为平滑，但随之而来的问题是，开发者们抱怨了多年的老问题依然存在。 ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准，已经在2015年6月正式发布了。Mozilla公司将在这个标准的基础上，推出JavaScript 2.0。 ECMAScript和JavaScript到底是什么关系？很多初学者会感到困惑，简单来说，ECMAScript是JavaScript语言的国际标准，JavaScript是ECMAScript的实现。 24.ECMAScript6 怎么写class么，为什么会出现class这种东西? ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。1234567891011 //定义类class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 25.异步加载的方式有哪些？ 方法一：也叫Script DOM Element12345678 (function()&#123; var scriptEle = document.createElement(\"script\"); scriptEle.type = \"text/javasctipt\"; scriptEle.async = true; scriptEle.src = \"http://cdn.bootcss.com/jquery/3.0.0-beta1/jquery.min.js\"; var x = document.getElementsByTagName(\"head\")[0]; x.insertBefore(scriptEle, x.firstChild); &#125;)(); 方法二：onload时的异步加载123456789101112131415(function()&#123; if(window.attachEvent)&#123; window.attachEvent(\"load\", asyncLoad); &#125;else&#123; window.addEventListener(\"load\", asyncLoad); &#125; var asyncLoad = function()&#123; var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true; ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s); &#125; &#125;)(); 方法三：其他方法 由于JavaScript的动态性，还有很多异步加载方法： XHR Injection、 XHR Eval、 Script In Iframe、 Script defer属性、 document.write(script tag)。 XHR Injection(XHR 注入)：通过XMLHttpRequest来获取javascript，然后创建一个script元素插入到DOM结构中。ajax请求成功后设置script.text为请求成功后返回的responseText。 有些JS代码在某些情况在需要使用，并不是页面初始化的时候就要用到。延迟加载就是为了解决这个问题。将JS切分成许多模块，页面初始化时只加载需要立即执行的JS，然后其它JS的加载延迟到第一次需要用到的时候再加载。类似图片的延迟加载。 JS的加载分为两个部分：下载和执行。异步加载只是解决了下载的问题，但是代码在下载完成后就会立即执行，在执行过程中浏览器处于阻塞状态，响应不了任何需求。 解决思路：为了解决JS延迟加载的问题，可以利用异步加载缓存起来，但不立即执行，需要的时候在执行。如何进行缓存呢？将JS内容作为Image或者Object对象加载缓存起来，所以不会立即执行，然后在第一次需要的时候在执行。 25.documen.write和 innerHTML的区别? document.write是直接写入到页面的内容流，如果在写之前没有调用document.open, 浏览器会自动调用open。每次写完关闭之后重新调用该函数，会导致页面被重写。 innerHTML则是DOM页面元素的一个属性，代表该元素的html内容。你可以精确到某一个具体的元素来进行更改。如果想修改document的内容，则需要修改document.documentElement.innerElement。 innerHTML将内容写入某个DOM节点，不会导致页面全部重绘 innerHTML很多情况下都优于document.write，其原因在于其允许更精确的控制要刷新页面的那一个部分。 26.DOM操作——怎样添加、移除、移动、复制、创建和查找节点? （1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 27..call() 和 .apply() 的含义和区别？ 我在一开始看到javascript的函数apply和call时,非常的模糊,看也看不懂,最近在网上看到一些文章对apply方法和call的一些示例,总算是看的有点眉目了,在这里我做如下笔记,希望和大家分享.. 如有什么不对的或者说法不明确的地方希望读者多多提一些意见,以便共同提高.. 1.apply和call的区别在哪里 2.什么情况下用apply,什么情况下用call 3.apply的其他巧妙用法（一般在什么情况下可以使用apply） 我首先从网上查到关于apply和call的定义,然后用示例来解释这两个方法的意思和如何去用. apply:方法能劫持另外一个对象的方法，继承另外一个对象的属性. Function.apply(obj,args)方法能接收两个参数 obj：这个对象将代替Function类里this对象 args：这个是数组，它将作为参数传给Function（args--&gt;arguments） call:和apply的意思一样,只不过是参数列表不一样. Function.call(obj,[param1[,param2[,…[,paramN]]]]) obj：这个对象将代替Function类里this对象 params：这个是一个参数列表","tags":[{"name":"前端面试常见问题","slug":"前端面试常见问题","permalink":"http://yaochuxia.github.io/tags/前端面试常见问题/"}]},{"title":"2017前端面试题","date":"2017-09-12T12:27:57.000Z","path":"2017/09/12/2017前端面试题/","text":"2017前端面试的一些常见考题。总结 1.谈谈对前端安全的理解，有什么，怎么防范?前端安全主要有XSS,CSRF攻击 XSS跨站脚本攻击 它允许用户将恶意代码植入到提供给其他用户使用的页面中，可以见到的理解为一种javascript代码注入。 XSS防御措施 1.过滤转义输出 2.避免使用eval，new Function等执行文字的字符串的方法，除非确定字符串和用户输入无关 3.使用cookie的httpOnly属性，加上了这个属性的cookie的字段，js是无法进行读写的。 4.使用innerHTML,document.write的时候，如果数据是用户输入的，那么需要 对象关键字进行过滤与转义的。 CSRF跨站请求伪造 其实就是网站中的一些提交行为，被黑客利用，在你访问黑客的网站的时候进行操作，会被操作到其他网站上 CSRF防御措施： 1.检测http referer是否是同域名 2.避免登录的session长时间存储在客户端中 3.关键请求使用验证码或者token机制 4.其他的一些攻击方法还有HTTP劫持、界面操作劫持 2.使用剪头函数需要注意的地方当要求动态上下的时候，你就不能使用剪头函数，比如：定义方法，用构造器创建对象，处理的时候用this获取目标。 3.webpack.load的原理loaders是你用在app源代码上的转换元件。他们是用node.js运行的，把原文件作为参数，返回新的资源的函数。 4.ES6 let,constlet let 是更完美的var 1.let声明的变量拥有块级作用域，let声明仍然保留了提升的特性，但不会盲目的提升。 2.let声明的全局变量不是全局对象的属性，不可以通过window变量名的方式访问。 3.形如for(let x...)的循环在每次迭代时都为x创建新的绑定。 4.let声明的变量直到控制流到达该变量被定义的代码行时才会被装截，所以在到达之前使用该变量会触发错误。const 定义常量值，不可以重新赋值，但是值如果是一个对象，可以改变对象里的属性值。 5.css3 box-sizing的作用设置css和模型为标准模型或IE模型，标准模型的宽度只包括content，二IE模型包括border和padding，box-sizing属性可以为三个值一： 1.content-box,默认值，border和padding值不算入width中。 2.padding－box，padding值算入width中。 3.border－box,border和padding值算入width中。 6.说说Html5中新增标签及语义化？（经常出现的题目）如果代码写的语义化，有利于seo。搜索引擎很容易读懂该网页要表达的意思，例如文本模块要有大标题，合理利用h1-h6，列表形式的代码使用ul和ol，重要的文字使用strong等等，总之要充分利用各种html标签完成它们的本职工作。 &lt; title&gt;&lt;/title&gt;：简短、描述性、唯一（提升搜索引擎排名）。 搜索引擎会将title作为判断页面主要内容的指标，有效的title应该包含几个与页面内容密切相关的关键字，建议将title核心内容放在前60个字符中。 h1~h6分级标题，用于创建页面信息的层级关系。 对于搜索引擎而言，如果标题与搜索词匹配，这些标题就会被赋予很高的权重，尤其是h1。 &lt;header&gt;&lt;/header&gt;：页眉通常包括网站标志、主导航、全站链接以及搜索框。 也适合对页面内部一组介绍性或导航性内容进行标记。 &lt;nav&gt;&lt;/nav&gt;：标记导航，仅对文档中重要的链接群使用。 html5规范不推荐对辅助性页脚链接使用nav，除非页脚再次显示顶级全局导航、或者包含招聘信息等重要链接。 &lt;main&gt;&lt;/main&gt;：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。 &lt;article&gt;&lt;/article&gt;：包含像报纸一样的内容= =||是这么理解的，表示文档、页面、应用或一个独立的容器。 article可以嵌套article，只要里面的article与外面的是部分与整体的关系。 &lt;section&gt;&lt;/section&gt;具有相似主题的一组内容，比如网站的主页可以分成介绍、新闻条目、联系信息等条块。如果只是为了添加样式，请用div！ &lt;aside&gt;&lt;/aside&gt;指定附注栏，包括引述、侧栏、指向文章的一组链接、广告、友情链接、相关产品列表等。如果放在main内，应该与所在内容密切相关。 &lt;footer&gt;&lt;/footer&gt;：页脚，只有当父级是body时，才是整个页面的页脚。 &lt;small&gt;&lt;/small&gt;：指定细则，输入免责声明、注解、署名、版权。只适用于短语，不要用来标记“使用条款”、“隐私政策”等长的法律声明。 &lt;strong&gt;&lt;/strong&gt;：表示内容重要性。 &lt;em&gt;&lt;/em&gt;：标记内容着重点（大量用于提升段落文本语义）。 &lt;mark&gt;&lt;/mark&gt;：突出显示文本（yellow），提醒读者。在HTML5中em是表示强调的唯一元素，而strong则表示重要程度。 &lt;b&gt;&lt;/b&gt;：出于实用目的提醒读者的一块文字，不传达任何额外的重要性 &lt;i&gt;&lt;/i&gt;：不同于其他文字的文字= =|||这个翻译真的是······ &lt;figure&gt;&lt;/figure&gt;：创建图（默认有40px左右margin）。 &lt;figcaption&gt;&lt;/figcaption&gt;：figure的标题，必须是figure内嵌的第一个或者最后一个元素。 &lt;cite&gt;&lt;/cite&gt;：指明引用或者参考，如图书的标题，歌曲、电影、等的名称，演唱会、音乐会、规范、报纸、或法律文件等。只用于参考源本身，而不是从中引述。 &lt;blockquoto&gt;&lt;/blockquoto&gt;：引述文本，默认新的一行显示。 &lt;q&gt;&lt;/q&gt;：短的引述（跨浏览器问题，尽量避免使用）。 可以对blockquoto和q元素使用cite属性（不是cite元素！），对搜索引擎自动化工具有用。cite=“URL”引述来源地址。 &lt;time&gt;&lt;/time&gt;：标记时间。datetime属性遵循特定格式，如果忽略此属性，文本内容必须是合法的日期或者时间格式.不再相关的时间用s标签。 &lt;abbr&gt;&lt;/abbr&gt;：解释缩写词。使用title属性可提供全称，只在第一次出现时使用就ok。 &lt;dfn&gt;&lt;/dfn&gt;：定义术语元素，与定义必须紧挨着，可以在描述列表dl元素中使用。 &lt;address&gt;&lt;/address&gt;：作者、相关人士或组织的联系信息（电子邮件地址、指向联系信息页的链接）。 如果提供整个页面的作者联系信息，一般放在页面级footer里。不能包含文档或者文档等其他内容。 &lt;del&gt;&lt;/del&gt;：移除的内容。 &lt;ins&gt;&lt;/ins&gt;：添加的内容。少有的既可以包围块级，又可以包围短语内容的元素。 &lt;code&gt;&lt;/code&gt;：标记代码。包含示例代码或者文件名 （&lt; &lt; &gt; &gt;） &lt;pre&gt;&lt;/pre&gt;：预格式化文本。保留文本固有的换行和空格。 &lt;progress&gt;&lt;/progress&gt;：完成进度。可通过js动态更新value。 7.HTML5有哪些新增表单元素？（经常出现的题目）datalist元素规定输入域的选项列表。keygen 元素的作用是提供一种验证用户的可靠方法。output 元素用于不同类型的输出 8.HTML5 存储类型有什么区别？（经常出现的题目）localStorage 适用于长期存储数据，浏览器关闭后数据不丢失sessionStorage 存储的数据在浏览器关闭后自动删除 9.HTML5标准提供了哪些新的API?Media APIText Track APIApplication Cache APIUser InteractionData Transfer APICommand APIConstraint Validation APIHistory API 10.你做过哪些性能优化?移动端响应式图片，静态资源CDN，减少Dom操作（事件代理、fragment），压缩JS和CSS、HTML等，DNS预解析 11.原型与闭包相关问题原型是什么原型就是一个普通的对象，每个对象都有一个原型（Object除外），原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。查看原型以前一般使用对象的proto属性，ES6推出后，推荐用Object.getPrototypeOf()方法来获取对象的原型 闭包是什么？专业说法：当一个内部函数被其外部函数之外的变量引用时，就形成了一个闭包。 还可以这么理解：闭包就是一个具有封闭功能与包裹功能的结构，是为了实现具有私有访问空间的函数的，函数可以构成闭包，因为函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量闭包的特性闭包有三个特性： 函数嵌套函数函数内部可以引用外部的参数和变量参数和变量不会被垃圾回收机制回收闭包有什么用，使用场景当我们需要在模块中定义一些变量，并希望这些变量一直保存在内存中但又不会“污染”全局的变量时，就可以用闭包来定义这个模块。 闭包的缺点闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 函数套函数就是闭包吗？不是！，当一个内部函数被其外部函数之外的变量引用时，才会形成了一个闭包。","tags":[{"name":"前端面试常见问题","slug":"前端面试常见问题","permalink":"http://yaochuxia.github.io/tags/前端面试常见问题/"}]},{"title":"前端js的splice方法","date":"2017-09-10T10:58:41.000Z","path":"2017/09/10/js的splice方法/","text":"splice(index,len,[item]) 注释：该方法会改变原始数组。 splice有3个参数，它也可以用来替换/删除/添加数组内某一个或者几个值 index:数组开始下标 len: 替换/删除的长度 item:替换的值，删除操作的话 item为空 例子：arr = [‘a’,’b’,’c’,’d’] 删除： arr.splice(1,1) //[‘a’,’c’,’d’] 删除起始下标为1，长度为1的一个值，len设置的1，如果为0，则数组不变 arr.splice(0,2) //[‘c’,’d’] 删除起始下标为1，长度为2的一个值，len设置的2 替换: arr.splice(1,1,’n’) //[“a”, “n”, “c”, “d”] 返回值为[“b”] arr.splice(1,2,’n’) //[“a”, “n”, “d”] 返回值为[“b”, “c”] 添加： arr.splice(1,0,’n’) //[“a”, “n”, “b”, “c”, “d”] 返回值为[]","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://yaochuxia.github.io/tags/Javascript/"}]},{"title":"怎么预览 GitHub 项目里的网页或 Demo","date":"2017-08-17T09:09:53.000Z","path":"2017/08/17/怎么预览-GitHub-项目里的网页或-Demo/","text":"怎么预览？好多html文件不能直接在浏览器里看？一定要下载下来？ 一：问题的所在相信很多小胖友们在把自己的网页上传到github仓库中，都会有一个疑问？是什么呢？那就是上传完网页后，自己的仓库中是这个样子的，点进去相应的html文件是出来的是代码可是自己想在网上看到自己仓库中的demo(也就是网页的效果)下面博猪为您解答 (^~^) 二：解决问题的方法 1: 使用 Githubpages比如我要上传 按照如下四个步骤上传到名为:flexSupplement的仓库中 git init (初始化本地仓库) git add . （将本地所有文件加到仓库里） git commit -m &quot;message&quot; （设置提交信息） git remote add origin git@github.com:yaochuxia/resume.git flexSupplement.git（本地仓库链接远程仓库） git push -u origin master （push文件到仓库中） 上传成功后是这个效果 重头戏来了哟！我们现在点击这个html文件，出现的效果全是代码 ，没有咱们想要的demo效果此时呢，应该植入咱们github爸爸的一个好东西，那就是-githubPages第一步：找到Settings第二步：找到githubPages第三步：预览githubPages小胖友们看到这里一定会有疑问，预览到的是githubpages的效果，并不是你自己网页的效果，没关系，我下面为你们解答第四步：查看你的分支 注意：我们生成githubPages的目的就是需要生成一个gh-pages分支(咱们正常情况下只有一个master分支)第五步：将远程仓库克隆到本地$ git@github.com:yaochuxia/resume.git第六步：将分支切换到gh-Pages $ cd flexSupplement （进入到你克隆仓库的本地文件夹）$ git checkout gh-pages（将master分支切换到gh-pages分支上）第七步：并重新上传到github上将本地克隆的文件删了，只留下.git,然后把你想要展示demo页面相关的文件粘进去接着，执行以下语句 git add .（将本地所有文件加到仓库里）git commit -m &quot;message&quot; （设置提交信息）git remote add origin git@github.com:sunningcarryhaha/flexSupplement.git（本地仓库链接远程仓库）git push -u origin gh-pages （push文件到仓库中） 第八步：修改地址我的GithubPages地址是这个：http://carryguan.me/flex-add我要预览flex-add中的fb1.html我最后预览的地址应该是这个：flexbox第九步：添加http://read.me把地址放到http://read.me中 flex-add这是一个关于flexbox基础的骰子布局 demo2: 增加路径前缀（不建议用，会自动更改css的样式）在地址前加GitHub &amp; BitBucket HTML Preview前缀（不建议用这个，会更改css样式）例如，你想预览这个：https://yaochuxia.github.io/resume/","tags":[]},{"title":"前端资源","date":"2016-12-29T06:08:20.000Z","path":"2016/12/29/前端资源/","text":"一些前端资源链接 前端知识体系 http://www.cnblogs.com/sb19871023/p/3894452.html 前端知识结构 https://github.com/JacksonTian/fks Web前端开发大系概览 https://github.com/unruledboy/WebFrontEndStack Web前端开发大系概览-中文版 http://www.cnblogs.com/unruledboy/p/WebFrontEndStack.html Web Front-end Stack v2.2 https://raw.githubusercontent.com/unruledboy/WebFrontEndStack/master/Web%20Front%20End%20Stack.png 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 前端书籍 https://github.com/dypsilon/frontend-dev-bookmarks 前端免费书籍大全 https://github.com/vhf/free-programming-books 免费的编程中文书籍索引 https://github.com/justjavac/free-programming-books-zh_CN 智能社 - 精通JavaScript开发 http://study.163.com/course/introduction/224014.htm 重新介绍 JavaScript（JS 教程） https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript 麻省理工学院公开课：计算机科学及编程导论 http://v.163.com/special/opencourse/bianchengdaolun.html JavaScript中的this陷阱的最全收集–没有之一 http://segmentfault.com/a/1190000002640298 JS函数式编程指南 https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch1.html JavaScript Promise迷你书（中文版） http://liubin.github.io/promises-book 腾讯移动Web前端知识库 https://github.com/AlloyTeam/Mars Front-End-Develop-Guide 前端开发指南 https://github.com/Front-End-Developers-Hunan/Front-End-Develop-Guide 前端开发笔记本 https://li-xinyang.gitbooks.io/frontend-notebook/content 大前端工具集 - 聂微东 https://github.com/nieweidong/fetool 前端开发者手册 https://dwqs.gitbooks.io/frontenddevhandbook/content 易迅网前端博客 https://github.com/YIXUNFE/blog 重新介绍 JavaScript（JS 教程） https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript 入门类 地址 前端入门教程 http://www.cnblogs.com/jikey/p/3613082.html 廖雪峰的Javascript教程 http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000 jQuery基础教程 http://www.imooc.com/view/11 前端工程师必备的PS技能——切图篇 http://www.imooc.com/view/506 结合个人经历总结的前端入门方法 https://github.com/qiu-deqing/FE-learning 效果类 地址 弹出层 http://www.imooc.com/learn/58 焦点图轮播特效 http://www.imooc.com/learn/18 工具类 地址 css sprite 雪碧图制作 http://www.imooc.com/learn/93 版本控制入门 – 搬进 Github http://www.imooc.com/learn/390 Grunt-beginner前端自动化工具 http://www.imooc.com/learn/30 慕课专题 地址 张鑫旭 - 慕课系列 http://www.imooc.com/space/teacher/id/197450 lyn - 慕课系列 http://www.imooc.com/space/teacher/id/104593 艾伦 - 慕课系列 http://www.imooc.com/space/teacher/id/290139 碧仔 - Hello，移动WEB http://www.imooc.com/view/494 周报类 地址 平安科技移动开发二队技术周报 https://github.com/PaicHyperionDev/MobileDevWeekly 开发中心 地址 mozilla js参考 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript chrome开发中心（chrome的内核已转向blink） https://developer.chrome.com/extensions/api_index.html safari开发中心 https://developer.apple.com/library/safari/navigation microsoft js参考 https://msdn.microsoft.com/zh-cn/library/d1et7k7c(v=vs.94.aspx js秘密花园 http://sanshi.me/articles/JavaScript-Garden-CN/html/index.html js秘密花园 http://bonsaiden.github.io/JavaScript-Garden/zh w3help http://www.w3help.org综合Bug集合网站 综合搜索 地址 javascripting http://www.javascripting.com 各种流行库搜索 http://microjs.com 综合API 地址 runoob.com-包含各种API集合 http://www.runoob.com 开源中国在线API文档合集 http://tool.oschina.net/apidocs devdocs http://devdocs.io英文综合API网站 jQuery 地址 jQuery API 中文文档 http://www.jquery123.com hemin 在线版 http://hemin.cn/jq css88 jq api http://www.css88.com/jqapi-1.9/on css88 jqui api http://www.css88.com/jquery-ui-api 学习jquery http://learn.jquery.com jquery 源码查找 http://james.padolsey.com/jquery Ecmascript 地址 Understanding ECMAScript 6 - Nicholas C. Zakas https://leanpub.com/understandinges6/read exploring-es6 https://leanpub.com/exploring-es6/read exploring-es6翻译 https://github.com/es6-org/exploring-es6 exploring-es6翻译后预览 http://es6-org.github.io/exploring-es6 阮一峰 es6 http://es6.ruanyifeng.com 阮一峰 Javascript http://javascript.ruanyifeng.com ECMA-262，第 5 版 http://yanhaijing.com/es5 es5 http://es5.github.io Js template 地址 template-chooser http://garann.github.io/template-chooser artTemplate https://github.com/aui/artTemplate tomdjs https://github.com/aui/tmodjs/blob/master/README.md 淘宝模板juicer模板 http://juicer.name/docs/docs_zh_cn.html Fxtpl v1.0 繁星前端模板引擎 http://koen301.github.io/fxtpl laytpl http://laytpl.layui.com mozilla - nunjucks https://github.com/mozilla/nunjucks Juicer https://github.com/PaulGuo/Juicer dustjs http://akdubya.github.io/dustjs etpl http://ecomfe.github.io/etpl 弹出层 地址 artDialog 最新版 https://github.com/aui/artDialog artDialog 文档 http://aui.github.io/artDialog/doc/index.html google code 下载地址 https://code.google.com/p/artdialog/downloads/list 贤心弹出层 http://layer.layui.com 响应式用户交互组件库 https://github.com/bh-lay/UI sweetalert-有css3动画弹出层 http://t4t5.github.io/sweetalert CSS 地址 CSS 语法参考 http://tympanus.net/codrops/css_reference CSS3动画手册 http://isux.tencent.com/css3/index.html 腾讯css3动画制作工具 http://isux.tencent.com/css3/tools.html 志爷css小工具集合 http://linxz.github.io/tianyizone css3 js 移动大杂烩 http://www.note12.com/category/blog/2014-6-5/538fe0a9f786f1b7019a4dfb bouncejs 触摸库 http://bouncejs.com css3 按钮动画 http://fian.my.id/Waves animate.css http://daneden.github.io/animate.css 全局CSS的终结(狗带 [译] http://www.alloyteam.com/2015/10/8536 Angularjs 地址 Angular.js 的一些学习资源 https://github.com/dolymood/AngularLearning angularjs中文社区 http://angularjs.cn Angularjs源码学习 http://www.cnblogs.com/xuwenmin888/p/3739096.html Angularjs源码学习 http://www.ifeenan.com/?c=AngularJS angular对bootstrap的封装 http://angular-ui.github.io/bootstrap angularjs + nodejs https://cnodejs.org/topic/51404e0f069911196d2e3923 吕大豹 Angularjs http://www.cnblogs.com/lvdabao/tag/AngularJs AngularJS 最佳实践 http://www.infoq.com/cn/news/2013/02/angular-web-app Angular的一些扩展指令 http://www.lovelucy.info/angularjs-best-practices.html Angular数据绑定原理 https://github.com/Pasvaz/bindonce 一些扩展Angular UI组件 https://github.com/angular-ui Ember和AngularJS的性能测试 http://voidcanvas.com/emberjs-vs-angularjs-performance-testing 带你走近AngularJS - 基本功能介绍 http://www.cnblogs.com/powertoolsteam/p/angularjs-introdection.html Angularjs开发指南 http://angular.duapp.com/docs/guide Angularjs学习 http://www.cnblogs.com/amosli/p/3710648.html 不要带着jQuery的思维去学习AngularJS http://www.rainweb.cn/article/angularjs-jquery.html angularjs 学习笔记 http://wangjiatao.diandian.com/?tag=angularjs angularjs 开发指南 http://www.angularjs.cn/T008 angularjs 英文资料 https://github.com/jmcunningham/AngularJS-Learning angular bootstrap http://angular-ui.github.io/bootstrap angular jq mobile https://github.com/opitzconsulting/jquery-mobile-angular-adapter angular ui http://mgcrea.github.io/angular-strap 整合jQuery Mobile+AngularJS经验谈 http://www.tuicool.com/articles/7ZZVr2 有jQuery背景，该如何用AngularJS编程思想 http://blog.jobbole.com/46589/ AngularJS在线教程 http://each.sinaapp.com/angular angular学习笔记 http://www.zouyesheng.com/angular.html React 地址 react.js 中文论坛 http://www.react-china.org react.js 官方网址 https://facebook.github.io/react/index.html react.js 官方文档 https://facebook.github.io/react/docs/getting-started.html react.js material UI http://material-ui.com/# react.js TouchstoneJS UI http://touchstonejs.io react.js amazeui UI http://amazeui.org/react React 入门实例教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html React Native 中文版 http://wiki.jikexueyuan.com/project/react-native Webpack 和 React 小书 - 前端乱炖 http://www.html-js.com/article/Fakefish%203053 Webpack 和 React 小书 - gitbook https://fakefish.github.io/react-webpack-cookbook webpack https://github.com/webpack/webpack Webpack，101入门体验 http://html-js.com/article/3009 webpack入门教程 http://html-js.com/article/3113 基于webpack搭建前端工程解决方案探索 http://segmentfault.com/a/1190000003499526 React原创实战视频教程 http://www.piliyu.com 移动端API 地址 99移动端知识集合 https://github.com/jtyjty99999/mobileTech 移动端前端开发知识库 https://github.com/AlloyTeam/Mars 移动前端的一些坑和解决方法（外观表现） http://caibaojian.com/mobile-web-bug.html 【原】移动web资源整理 http://www.cnblogs.com/PeunZhang/p/3407453.html zepto 1.0 中文手册 http://mweb.baidu.com/zeptoapi zepto 1.0 中文手册 http://www.html-5.cn/Manual/Zepto zepto 1.1.2 http://www.css88.com/doc/zeptojs_api zepto 中文注释 http://www.cnblogs.com/sky000/archive/2013/03/29/2988952.html jqmobile 手册 http://app-framework-software.intel.com/api.php 移动浏览器开发集合 https://github.com/maxzhang/maxzhang.github.com/issues 移动开发大杂烩 https://github.com/hoosin/mobile-web-favorites 微信webview中的一些问题 http://lin-chao.github.io/2014/11/14/%E5%BE%AE%E4%BF%A1webview%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98 框架 地址 特色的HTML框架可以创建精美的iOS应用 http://framework7.taobao.org 淘宝SUI http://m.sui.taobao.org avalon 地址 avalonjs http://avalonjs.github.io Avalon新一代UI库： OniUI http://ued.qunar.com/oniui/index.html avalon.oniui-基于avalon的组件库 https://github.com/RubyLouvre/avalon.oniui Requriejs 地址 Javascript模块化编程（一）：模块的写法 http://www.ruanyifeng.com/blog/2012/10/javascript_module.html Javascript模块化编程（二）：AMD规范 http://www.ruanyifeng.com/blog/2012/10/asynchronous_module_definition.html Javascript模块化编程（三）：require.js的用法 http://www.ruanyifeng.com/blog/2012/11/require_js.html RequireJS入门（一） http://www.cnblogs.com/snandy/archive/2012/05/22/2513652.html RequireJS入门（二） http://www.cnblogs.com/snandy/archive/2012/05/23/2513712.html RequireJS进阶（三） http://www.cnblogs.com/snandy/archive/2012/06/08/2538001.html requrie源码学习 http://www.cnblogs.com/yexiaochai/p/3632580.html requrie 入门指南 http://www.oschina.net/translate/getting-started-with-the-requirejs-library requrieJS 学习笔记 http://www.cnblogs.com/yexiaochai/p/3214926.html requriejs 其一 http://cyj.me/why-seajs/requirejs/ require backbone结合 http://www.cnblogs.com/yexiaochai/p/3221081.html Seajs 地址 seajs http://seajs.org seajs 中文手册 http://cyj.me/why-seajs/zh Less,sass 地址 sass http://www.w3cplus.com/sassguide sass教程-sass中国 http://www.sass.hk Sass 中文文档 http://sass.bootcss.com less http://less.bootcss.com Markdown 地址 Markdown 语法说明 (简体中文版 http://wowubuntu.com/markdown markdown入门参考 https://github.com/LearnShare/Learning-Markdown/blob/master/README.md gitbook https://www.gitbook.com国外的在线markdown可编辑成书 mdeditor https://www.zybuluo.com/mdeditor一款国内的在线markdown编辑器 stackedit https://stackedit.io国外的在线markdown编辑器，功能强大，同步云盘 mditor http://bh-lay.github.io/mditor一款轻量级的markdown编辑器 lepture-editor https://github.com/lepture/editor markdown-editor https://github.com/jbt/markdown-editor D3 地址 d3 Tutorials https://github.com/mbostock/d3/wiki/Tutorials Gallery https://github.com/mbostock/d3/wiki/Gallery lofter http://datavisual.lofter.com/post/40cf3a_188e535 iteye http://alanland.iteye.com/blog/1878595 ruanyifeng http://javascript.ruanyifeng.com/library/d3.html 兼容性 地址 esma 兼容列表 http://kangax.github.io/compat-table/es6 W3C CSS验证服务 http://jigsaw.w3.org/css-validator/validator.html.zh-cn caniuse http://caniuse.com/#index csscreator http://csscreator.com/properties microsoft https://msdn.microsoft.com/zh-cn/library/cc351024(v=vs.85.aspx 在线测兼容-移动端 http://www.responsinator.com emulators https://www.manymo.com/emulators UI相关 地址 bootcss http://v3.bootcss.com MetroUICSS http://www.w3cplus.com/MetroUICSS semantic http://semantic-ui.com Buttons http://alexwolfe.github.io/Buttons kitecss http://hiloki.github.io/kitecss pintuer http://www.pintuer.com amazeui http://amazeui.org worldhello http://www.worldhello.net/gotgithub/index.html linuxtoy http://igit.linuxtoy.org/contents.html gitmagic http://www-cs-students.stanford.edu/~blynn/gitmagic/intl/zh_cn rogerdudler http://rogerdudler.github.io/git-guide/index.zh.html gitref http://gitref.justjavac.com book http://git-scm.com/book/zh gogojimmy http://gogojimmy.net/2012/01/17/how-to-use-git-1-git-basic HTTP 地址 HTTP API 设计指南 http://segmentfault.com/bookmark/1230000002521721 其它API 地址 javascript流行库汇总 javascriptoo 验证api http://niceue.com/validator/demo/index.php underscore 中文手册 http://www.css88.com/doc/underscore underscore源码分析 http://www.html-js.com/article/Underscorejs-source-code-analysis-of-underscorejs-source-code-analysis%203031 underscore源码分析-亚里士朱德的博客 http://yalishizhude.github.io/tags/underscore underscrejs en api http://underscorejs.org lodash - underscore的代替品 https://lodash.com ext4api http://extjs-doc-cn.github.io/ext4api backbone 中文手册 http://www.csser.com/tools/backbone/backbone.js.html qwrap手册 http://dev.qwrap.com/resource/js/_docs/_youa/#/qw/base/loadJs_.htm 缓动函数 http://easings.net/zh-cn svg 中文参考 http://www.w3school.com.cn/svg/svg_reference.asp svg mdn参考 https://developer.mozilla.org/en-US/docs/Web/SVG svg 导出 canvas https://github.com/gabelerner/canvg svg 导出 png https://github.com/exupero/saveSvgAsPng ai-to-svg http://www.zamzar.com/convert/ai-to-svg localStorage 库 https://github.com/machao/localStorage 图表类 地址 Highcharts 中文API http://www.hcharts.cn/api/index.php Highcharts 英文API http://api.highcharts.com/highcharts ECharts 百度的图表软件 http://echarts.baidu.com/ 高德地图 http://lbs.amap.com/api 开源的矢量图脚本框架 http://paperjs.org svg 地图 http://jvectormap.com vue 地址 Vue http://cn.vuejs.org Vue 论坛 http://forum.vuejs.org Vue 入门指南 http://www.cnblogs.com/aaronjs/p/3660102.html Vue 的一些资源索引 http://segmentfault.com/a/1190000000411057 awesome-vue https://github.com/vuejs/awesome-vue 正则 地址 JS正则表达式元字符 http://segmentfault.com/a/1190000002471140 正则表达式30分钟入门教程 http://deerchao.net/tutorials/regex/regex.htm MDN-正则表达式 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions ruanyifeng - RegExp对象 http://javascript.ruanyifeng.com/stdlib/regexp.html 小胡子哥 - 进阶正则表达式 http://div.io/topic/764?page=1 is.js https://github.com/Cedriking/is.js/blob/master/is.js 正则在线测试 http://regexper.com ionic 地址 ionic https://github.com/ychow/ionic-guide 其它 地址 Mock.js 是一款模拟数据生成器 http://mockjs.com 前端 地址 通过分析github代码库总结出来的工程师代码书写习惯 http://alloyteam.github.io/CodeGuide HTML&amp;CSS编码规范 by @mdo http://codeguide.bootcss.com 团队合作的css命名规范-腾讯AlloyTeam前端团队 http://www.alloyteam.com/2011/10/107 前端编码规范之js - by yuwenhui http://yuwenhui.github.io 前端编码规范之js - by 李靖 http://www.cnblogs.com/hustskyking/p/javascript-spec.html 前端开发规范手册 http://zhibimo.com/read/Ashu/front-end-style-guide Airbnb JavaScript 编码规范（简体中文版） https://github.com/yuche/javascript#table-of-contents AMD与CMD规范的区别 http://www.zhihu.com/question/20351507 AMD与CMD规范的区别 http://www.cnblogs.com/tugenhua0707/p/3507957.html KISSY 源码规范 http://docs.kissyui.com/1.4/docs/html/tutorials/style-guide/kissy-source-style.html bt编码规范 http://codeguide.bootcss.com 规范加强版 https://github.com/Suxiaogang/Code_Guide 前端代码规范 及 最佳实践 http://blog.jobbole.com/79075 百度前端规范 http://coderlmn.github.io/code-standards 百度前端规范 http://isobar-idev.github.io/code-standards 百度前端规范 http://zhuanlan.zhihu.com/fuyun/19884834 ECMAScript6 编码规范–广发证券前端团队 https://github.com/gf-rd/es6-coding-style JavaScript 风格指南/编码规范（Airbnb公司版） http://blog.jobbole.com/79484 网易前端开发规范 http://nec.netease.com/standard css模块 http://www.75team.com/archives/1049 前端规范资源列表 https://github.com/ecomfe/spec PHP 地址 最流行的PHP 代码规范 http://segmentfault.com/a/1190000000443795 最流行的PHP 代码规范 https://github.com/hfcorriez/fig-standards/blob/zh_CN/%E6%8E%A5%E5%8F%97/PSR-2-coding-style-guide.md Android 地址 【敏捷开发】Android团队开发规范 http://www.cnblogs.com/lcw/p/3619181.html Android 开发规范与应用 http://www.jianshu.com/p/4390f4fe19b3 各大公司开源项目 地址 Facebook Projects https://code.facebook.com/projects/web 百度web前端研发部 http://fex.baidu.com 百度EFE http://efe.baidu.com 百度github https://github.com/fex-team alloyteam http://www.alloyteam.com alloyteam-github http://alloyteam.github.io alloyteam-AlloyGameEngine https://github.com/AlloyTeam/AlloyGameEngine AlloyDesigner http://alloyteam.github.io/AlloyDesigner即时修改，即时保存，设计稿较正，其它开发辅助工具 H5交互页编辑器AEditor介绍 http://www.alloyteam.com/2015/06/h5-jiao-hu-ye-bian-ji-qi-aeditor-jie-shaoH5动画交互页开发的工具介绍 AEditor http://aeditor.alloyteam.comH5动画交互页开发的工具 maka http://forum.maka.im/wordpress 值得订阅的weekly https://github.com/fenbility/weekly-feed 腾讯html5 http://cube.qq.com 奇舞团开源项目 http://75team.github.io Qunar UED http://ued.qunar.com Scrat http://scrat.io 常用 地址 ieBetter.js-让IE6-IE8拥有IE9+,Chrome等浏览器特性 http://www.zhangxinxu.com/wordpress/2013/12/iebetter-js-make-ie6-ie8-like-modern-browser-ie9-chrome 模拟键盘 http://mottie.github.io/Keyboard 拼音 https://github.com/hotoo/pinyin 中国个人身份证号验证 https://github.com/mc-zone/IDValidator 算法 地址 数据结构与算法 JavaScript 描述. 章节练习 https://github.com/Ralph-Wang/algorithm.in.js 常见排序算法（JS版） https://github.com/twobin/twobinSort 经典排序 https://github.com/luofei2011/jsAgm/blob/master/js/sort.js 常见排序算法-js版本 https://github.com/hechangmin/jssort JavaScript 算法与数据结构 精华集 https://github.com/lightningtgc/JavaScript-Algorithms 面试常考算法题精讲 http://www.nowcoder.com/live/courses JSON 地址 模拟生成JSON数据 http://beta.json-generator.com 返回跨域JSONAPI http://jsonp.afeld.me Html5 地址 HTML5 有哪些让你惊艳的 demo？ http://www.zhihu.com/question/24398907 CSS 地址 browserhacks http://browserhacks.com 焦点图 地址 myfocus https://github.com/koen301/myfocus myfocus-官方演示站 http://www.chhua.com/myfocus SuperSlidev2.1 – 大话主席 http://www.superslide2.com soChange http://www.bujichong.com/sojs/soChange/index.html Ext, EasyUI, J-UI 及其它各种UI方案 地址 extjs https://www.sencha.com/products/extjs ext4英文api http://docs.sencha.com/extjs/4.0.7 ext4中文api http://extjs-doc-cn.github.io/ext4api EasyUI 地址 jquery easyui 未压缩源代码 http://jquery-easyui.googlecode.com/svn/trunk/src J-UI 地址 J-UI http://jui.org Other 地址 MUI-最接近原生APP体验的高性能前端框架 http://dcloudio.github.io/mui Amaze UI 中国首个开源 HTML5 跨屏前端框架 淘宝 HTML5 前端框架 http://m.sui.taobao.org KISSY - 阿里前端JavaScript库 http://docs.kissyui.com 网易Nej - Nice Easy Javascript http://nej.netease.com Kendo UI MVVM Demo http://demos.telerik.com/kendo-ui/mvvm/index Bootstrap http://www.bootcss.com Smart UI http://smartui.chinamzz.com 雅虎UI - CSS UI http://developer.yahoo.com/yui/grids 页面 社会化 分享功能 地址 百度分享 http://share.baidu.compc端 JiaThis http://jiathis.compc端 社会化分享组件 http://developer.baidu.com/soc/share移动端 ShareSDK 轻松实现社会化功能 http://www.mob.com/#/index移动端 友盟分享 http://dev.umeng.com/social/android/quick-integration移动端 富文本编辑器 地址 功能齐全 tinymce https://www.tinymce.com 百度 ueditor http://ueditor.baidu.com/website 经典的ckeditor http://ckeditor.com 经典的kindeditor http://kindeditor.net wysiwyg http://www.bootcss.com/p/bootstrap-wysiwyg 一个有情怀的编辑器。Bach’s Editor http://integ.github.io/BachEditor tower用的编辑器 https://github.com/mycolorway/simditor summernote 编辑器 https://github.com/summernote/summernote html5编辑器 http://neilj.github.io/Squire XEditor http://lab.hustlzp.com/XEditor wangEditor https://github.com/wangfupeng1988/wangEditor PC 地址 经典my97 http://www.my97.net/dp/demo/index.htm 强大的独立日期选择器 http://www.cnblogs.com/gbin1/archive/2012/04/16/2452105.html fullcalendar http://fullcalendar.io fullcalendar日历控件知识点集合 http://blog.csdn.net/francislaw/article/details/7740630 中文api http://blog.sina.com.cn/s/blog_9475b1c101012c5f.html 农历日历 https://github.com/zzyss86/LunarCalendar 超酷的仿百度带节日日历老黄历控件 http://www.sucaisj.com/jiaoben/date/201509/16856.html 日期格式化 http://momentjs.com 大牛日历控件 https://github.com/Johnqing/QPAYCalendar 我群某管理作品 https://github.com/Iamlars/dateMarker input按位替换-官网 http://digitalbush.com/projects/masked-input-plugin input按位替换-github https://github.com/digitalBush/jquery.maskedinput/tree/1.2.2 bootstrap-daterangepicker https://github.com/dangrossman/bootstrap-daterangepicker 国外30个插件集合 http://www.vandelaydesign.com/30-best-free-jquery-plugins JavaScript datepicker http://dbushell.com/2012/10/09/pikaday-javascript-datepicker Datepair.js http://jonthornton.github.io/Datepair.js 一个风格多样的日历 https://github.com/glad/glDatePicker 弹出层式的全日历 http://amsul.ca/pickadate.js/date jquery双日历 http://www.daterangepicker.com Date library 地址 Datejs https://github.com/datejs/Datejs sugarjs http://sugarjs.com/api/Date 综合效果搜索平台 地址 效果网 http://www.jq22.com 17素材 http://www.17sucai.com 常用的JavaScript代码片段 http://microjs.com 概述 地址 前端工具大全 http://www.awesomes.cn 什么是前端工程化 https://github.com/fouber/blog/issues/10?from=timeline&amp;isappinstalled=0# Gulp 地址 Gulp官网 http://gulpjs.com Gulp中文网 http://www.gulpjs.com.cn gulp资料收集 https://github.com/Platform-CUF/use-gulp Gulp：任务自动管理工具 - ruanyifeng http://javascript.ruanyifeng.com/tool/gulp.html Gulp插件 http://gulpjs.com/plugins Gulp不完全入门教程 http://www.ido321.com/1622.html 为什么使用gulp? https://github.com/hjzheng/CUF_meeting_knowledge_share/issues/33 Gulp安装及配合组件构建前端开发一体化 http://www.dbpoo.com/getting-started-with-gulp Gulp 入门指南 https://github.com/nimojs/gulp-book Gulp 入门指南 - nimojs https://github.com/nimojs/blog/issues/19 Gulp入门教程 http://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B Gulp in Action http://www.imooc.com/video/5692 Gulp开发教程（翻译） http://www.w3ctech.com/topic/134 前端构建工具gulpjs的使用介绍及技巧 http://www.cnblogs.com/2050/p/4198792.html Grunt 地址 gruntjs http://gruntjs.com Grunt中文网 http://www.gruntjs.net Fis 地址 fis 官网 http://fex-team.github.io/fis-site/index.html fis http://fis.baidu.com pc图轮 地址 单屏轮播sochange http://www.jsfoot.com/jquery/demo/2011-09-20/192.html 左右按钮多图切换 http://bxslider.com/examples/carousel-demystified fullpage全屏轮播 https://github.com/alvarotrigo/fullPage.js 移动端 地址 无缝切换 http://www.swipejs.com 滑屏效果 http://www.idangero.us/swiper 全屏fullpage https://github.com/peunzhang/fullpage 单个图片切换 https://github.com/qiqiboy/touchslider 单个全屏切换 https://github.com/peunzhang/slip.js 百度的切换库 http://touch.code.baidu.com/examples.html?qq-pf-to=pcqq.group 单个全屏切换 https://github.com/peunzhang/iSlider 滑屏效果 https://github.com/saw/touch-interfaces 旋转拖动设置 http://baijs.com/tinycircleslider 类似于swipe切换 http://touchslider.com 支持多种形式的触摸滑动 http://www.swiper.com.cn/demo/index.html 滑屏效果 https://github.com/joker-ye/main/blob/master/wap/index.html 大话主席pc移动图片轮换 http://www.superslide2.com 滑屏效果 https://github.com/hahnzhu/parallax.js 基于zepto的fullpage https://github.com/yanhaijing/zepto.fullpage [WebApp]定宽网页设计下，固定宽度布局开发WebApp并实现多终端下WebApp布局自适应 http://www.cnblogs.com/plums/archive/2013/01/10/WebApp-fixed-width-layout-of-multi-terminal-adapter-since.html 判断微信客户端的那些坑 http://loo2k.com/blog/detecting-wechat-client 可以通过javascript直接调用原生分享的工具 https://github.com/JefferyWang/nativeShare.js JiaThis 分享到微信代码 http://www.jiathis.com/help/html/weixin-share-code 聊聊移动端跨平台开发的各种技术 http://fex.baidu.com/blog/2015/05/cross-mobile 前端自动化测试 http://www.zhihu.com/question/29922082 多种轮换图片 http://ajccom.github.io/niceslider 滚动条组件 http://ajccom.github.io/nicescroller 滑动侧边栏 https://mango.github.io/slideout 大气实用jQuery手机移动端日历日期选择插件 http://www.frankdemo.cn/index.php?c=content&amp;a=show&amp;id=115 jQuery Mobile 移动开发中的日期插件Mobiscroll https://mobiscroll.com fastclick https://github.com/ftlabs/fastclick no-click-delay https://github.com/mmastrac/jquery-noclickdelay 文件上传 地址 百度上传组件 http://fex.baidu.com/webuploader 上传 https://blueimp.github.io/jQuery-File-Upload flash 头像上传 http://www.hdfu.net 图片上传预览 http://www.dropzonejs.com 图片裁剪 http://elemefe.github.io/image-cropper 图片裁剪-shearphoto http://www.shearphoto.com jQuery图片处理 http://www.oschina.net/project/tag/284/jquery-image-tools?lang=0&amp;os=0&amp;sort=view&amp;p=2 模拟select 地址 糖饼 select http://aui.github.io/popupjs/doc/selectbox.html flexselect https://github.com/rmm5t/jquery-flexselect 双select http://loudev.com select2 http://select2.github.io 取色插件 地址 类似 Photoshop 的界面取色插件 http://www.jq22.com/plugin/367 jquery color https://github.com/jquery/jquery-color 取色插件集合 http://www.oschina.net/project/tag/287/color-picker farbtastic 圆环＋正方形 https://github.com/mattfarina/farbtastic 城市联动 地址 jquery.cityselect.js基于jQuery+JSON的省市或自定义联动效果 http://www.ijquery.cn/?p=360 剪贴板 地址 剪贴板 https://github.com/zeroclipboard/zeroclipboard clipboard 最新的剪切方案 http://zenorocha.github.io/clipboard.js 不是Flash的剪贴板 https://github.com/zenorocha/clipboard.js 简繁转换 地址 简繁转换 https://github.com/BYVoid/OpenCC 表格 Grid 地址 facebook表格 http://facebook.github.io/fixed-data-table 类似于Excel编辑表格-handsontable http://handsontable.com bootstrap-table插件 http://bootstrap-table.wenzhixin.net.cn datatables https://www.datatables.net 在线演示 地址 js 在线编辑 - runjs http://runjs.cn js 在线编辑 - jsbin http://jsbin.com js 在线编辑 - codepen http://codepen.io js 在线编辑 - jsfiddle http://jsfiddle.net java 在线编辑 - runjs http://ideone.com js 在线编辑 - hcharts http://code.hcharts.cn js 在线编辑 - jsdm http://jsdm.com sql 在线编辑 - sqlfiddle http://sqlfiddle.com mozilla 在线编辑器 https://thimble.mozilla.org 播放器 地址 Html5 VideoPlayer https://github.com/zmmbreeze/DeadSimpleVideoPlayer 粒子动画 地址 Proton 烟花 http://a-jie.github.io/Proton/#example Nodejs 地址 nodejs 篇幅比较巨大 http://liuqing.pw Node.js 包教不包会 https://github.com/alsotang/node-lessons 篇幅比较少 http://www.rainweb.cn/article/category/Nodejs node express 入门教程 http://www.w3cfuns.com/article-5598538-1-1.html nodejs定时任务 http://my.oschina.net/u/568264/blog/193773 一个nodejs博客 http://60sky.com 【NodeJS 学习笔记04】新闻发布系统 http://www.cnblogs.com/yexiaochai/p/3536547.html 过年7天乐，学nodejs 也快乐 http://www.cnblogs.com/qqloving/p/3541099.html 七天学会NodeJS https://github.com/nqdeng/7-days-nodejs Nodejs学习笔记（二）— 事件模块 http://www.cnblogs.com/zhongweiv/p/nodejs_events.html nodejs入门 http://www.cnblogs.com/liusuqi/p/3735491.html angularjs nodejs https://github.com/zensh/jsgen 从零开始nodejs系列文章 http://blog.fens.me/series-nodejs 理解nodejs http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb nodejs事件轮询 http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop node入门 http://www.nodebeginner.org/index-zh-cn.html nodejs cms http://ourjs.com/detail/53e1f281c5910a9806000001 Node初学者入门，一本全面的NodeJS教程 http://ourjs.com/detail/529ca5950cb6498814000005 NodeJS的代码调试和性能调优 http://www.barretlee.com/blog/2015/10/07/debug-nodejs-in-command-line 常规优化 地址 Javascript高性能动画与页面渲染 http://www.infoq.com/cn/articles/javascript-high-performance-animation-and-page-rendering 移动H5前端性能优化指南 http://isux.tencent.com/h5-performance.html 5173首页前端性能优化实践 http://ued.5173.com/?p=1731 给网页设计师和前端开发者看的前端性能优化 http://www.uisdc.com/front-end-performance-for-web-designers-and-front-end-developers 复杂应用的 CSS 性能分析和优化建议 http://www.orzpoint.com/profiling-css-and-optimization-notes 张鑫旭——前端性能 http://www.zhangxinxu.com/wordpress/tag/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD 前端性能监控总结 http://www.xiaoqiang.org/javascript/font-end-performance-monitor.html 网站性能优化之CSS无图片技术 http://udc.weibo.com/2013/05/%E7%BD%91%E7%AB%99%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8Bcss%E6%97%A0%E5%9B%BE%E7%89%87%E6%8A%80%E6%9C%AF web前端性能优化进阶路 http://www.aliued.cn/2013/01/20/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%BF%9B%E9%98%B6%E8%B7%AF.html 前端技术：网站性能优化之CSS无图片技术 http://my.eoe.cn/tuwandou/archive/4544.html 浏览器的加载与页面性能优化 http://www.baiduux.com/blog/2011/02/15/browser-loading 页面加载中的图片性能优化 http://www.w3ctech.com/p/1503 Hey——前端性能 http://www.feelcss.com/tag/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD html优化 http://www.baiduux.com/blog/2010/03/15/html%E4%BC%98%E5%8C%96-2 99css——性能 http://www.99css.com/tag/%e6%80%a7%e8%83%bd Yslow——性能优化 http://www.yslow.net/category.php?cid=20 YSLOW中文介绍 http://www.cnblogs.com/yslow 转一篇Yahoo关于网站性能优化的文章，兼谈本站要做的优化 http://www.360ito.com/article/40.html Yahoo!团队实践分享：网站性能 http://www.360doc.com/content/10/0928/09/2588264_56971287.shtml 网站性能优化指南：什么使我们的网站变慢？ http://blog.jiasule.com/i/153 网站性能优化实践，减少加载时间，提高用户体验 http://www.powereasy.net/helpyou/knowledge/ecommerce/9593.html 浅谈网站性能优化 前端篇 http://www.umtry.com/archives/747.html 前端重构实践之如何对网站性能优化？ http://www.adinnet.cn/blog/designview/2012-7-12/678.html 前端性能优化：使用媒体查询加载指定大小的背景图片 http://www.gbin1.com/technology/javascript/20130708-front-end-performance-optimization-9 网站性能系列博文 http://www.mykuer.com/post/factors-that-affect-the-speed-of-web-site-open.html 加载，不只是少一点点 http://tgideas.qq.com/webplat/info/news_version3/804/808/811/m579/201109/41355.shtml 前端性能的测试与优化 http://mzhou.me/article/95310 分享网页加载速度优化的一些技巧？ http://www.gbin1.com/technology/html/20130217-tips-for-speed-up-page-loading 页面加载中的图片性能优化 http://www.f2es.com/images-bytes-opt web前端优化(基于Yslow http://www.tcreator.info/webSchool/website/Front-end-Opt-Yslow.html 网站性能优化工具大全 https://www.qianduan.net/website-performance-optimization-tool.html 【高性能前端1】高性能HTML http://www.alloyteam.com/2012/10/high-performance-html 【高性能前端2】高性能CSS http://www.alloyteam.com/2012/10/high-performance-css 由12306谈谈网站前端性能和后端性能优化 http://coolshell.cn/articles/6470.html AlloyTeam——前端优化 http://www.alloyteam.com/webfrontend/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96 毫秒必争，前端网页性能最佳实践 http://www.cnblogs.com/developersupport/p/3248695.html 网站性能工具Yslow的使用方法 http://blog.sina.com.cn/s/blog_6e9d2e0701017kvu.html 前端工程与性能优化（上）：静态资源版本更新与缓存 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part1 前端工程与性能优化（下）：静态资源管理与模板框架 http://www.infoq.com/cn/articles/front-end-engineering-and-performance-optimization-part2 HTTPS连接的前几毫秒发生了什么 http://blog.jobbole.com/48369 Yslow http://uicss.cn/yslow/#more-12319 Essential Web Performance Metrics — A Primer, Part 1 http://blog.smartbear.com/web-performance/essential-web-performance-metrics-a-primer-part-1 Essential Web Performance Metrics — Part 2 http://blog.smartbear.com/performance/essential-web-performance-metrics-part-2 YUISlide,针对移动设备的动画性能优化 http://jayli.github.io/blog/data/2011/12/23/yuislide.html Improving Site Performance http://joelglovier.com/improving-site-performance 让网站提速的最佳前端实践 http://segmentfault.com/a/1190000000367899 Why Website Speed is Important http://sixrevisions.com/web-development/why-website-speed-is-important Need for Speed – How to Improve your Website Performance https://www.devbridge.com/articles/need-for-speed-how-to-improve-your-website-performance 阿里无线前端性能优化指南 (Pt.1 加载期优化 https://github.com/amfe/article/issues/1 优化工具 地址 JavaScript 性能分析新工具 OneProfile http://www.html-js.com/article/3083 JavaScript 堆内存分析新工具 OneHeap http://www.html-js.com/article/3091 在线工具 地址 google在线工具 https://developers.google.com/speed/pagespeed/insights 阿里测 http://www.alibench.com 阿里-免费测试服务 http://itest.aliyun.com 阿里-F2etest多浏览器兼容性测试解决方案 https://github.com/alibaba/f2etest js性能测试 http://jsperf.com 前端架构 地址 技术架构 http://www.zhihu.com/topic/19612641 前端架构 http://saito.im/note/The-Architecture-of-F2E 如何成为前端架构师 http://www.zhihu.com/question/24092572 关于前端架构-张克军 http://hikejun.com/sharing/2010webrebuild/?file=fe-infrastructure.html 百度腾讯offer比较（腾讯游戏VS百度基础架构） http://www.zhihu.com/question/25583350 推荐作品 地址 winter代码片段需要翻墙 https://gist.github.com/wintercn fgm http://www.fgm.cc/learn 岑安作品集 https://github.com/hongru/hongru.github.com 当耐特demo集合 http://kmdjs.github.io 米空格 js作品 http://www.laoshu133.com/Lab myFocus http://koen301.github.io SeaJS组件库 http://panxuepeng.github.io/seajslib 颜海镜作品 http://yanhaijing.com/myProject 脚儿网作品 http://jo2.org/category/myworks javascript个人作品 http://www.cnitblog.com/yemoo/category/3107.html 妙味的雷东升游戏作品 http://bbs.miaov.com/forum.php?mod=viewthread&amp;tid=7790 javascript作品集 http://bbs.csdn.net/topics/380227212 云五笔，灰度产生生成工具 https://github.com/TooBug/works 项目主页 http://koen301.github.io 个性的作品主页 http://zaole.net 播放器 http://static.tingall.com/v2/player ucren js demos 集 http://ucren.com/blog/demos 智能社 http://www.zhinengshe.com/works_list.html 实例陈列架 http://demos.shizuwu.cn zoye demo http://zoye.sinaapp.com/demo 王员外 http://lab.yuanwai.wang 平凡 http://pingfan1990.sinaapp.com jyg 游戏案例 http://www.lovewebgames.com 很多jquery插件 http://www.helloweba.com/list.html 不羁虫 - soJs 作品系列 http://www.bujichong.com/sojs/api/index.html frozenui http://frozenui.github.io/case.html 黑白棋 http://js-game.github.io/othello fromone http://yansm.github.io/fromone/index.html 国外大牛精品 地址 pazguille http://pazguille.me 简历模板 地址 不错的个人简历 http://learnshare.github.io/about/index.html 简历 http://hcy2367.github.io/resume 张伦 http://ncuey.sinaapp.com/CrispElite/ 简历 https://github.com/hacke2/ResumeSample 翁天信 http://blog.dandyweng.com/2013/07/how-my-website-was-created 动画方式的简历 http://www.webhek.com/misc/interactive-resume 组件丰富简历 http://www.linqing07.com/resume.html 简历池 http://www.mojianli.com/resume/view haorooms博客 http://www.haorooms.com/about Justin Young http://cv.youngdze.com 面试题 地址 那几个月在找工作（百度，网易游戏） http://www.nowcoder.com/discuss/3196 2014最新面试题 http://www.html-js.com/article/1743 阿里前端面试题 http://www.w3cfuns.com/thread-5598563-2-1.html 2016校招内推 – 阿里巴巴前端 – 三面面试经历 http://www.cnblogs.com/imwtr/p/4685546.html 腾讯面试题 http://www.w3cfuns.com/article-5599657-1-1.html 年后跳槽那点事：乐视+金山+360面试之行 http://www.cnblogs.com/lvdabao/p/3660707.html 阿里前端面试题上线 http://fatesinger.com/2722.html 拉勾网js面试题 http://www.cnblogs.com/52cik/p/js-question-lg.html 前端面试 http://www.cnblogs.com/allenxing/p/3724382.html Web开发笔试面试题 大全 http://mianshiti.diandian.com 前端开发面试题 http://segmentfault.com/a/1190000000465431 2014最新前端面试题 https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions 百度面试 https://github.com/fex-team/interview-questions 面试题 http://www.w3cfuns.com/forum.php?mod=forumdisplay&amp;fid=51&amp;filter=typeid&amp;typeid=177 前端工作面试问题 https://github.com/darcyclarke/Front-end-Developer-Interview-Questions/tree/master/Chinese 前端开发面试题 http://segmentfault.com/a/1190000000465431 5个经典的前端面试问题 http://ourjs.com/detail/5%E4%B8%AA%E7%BB%8F%E5%85%B8%E7%9A%84%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98 最全前端面试问题及答案总结 http://segmentfault.com/a/1190000002562454 如何面试一名前端开发工程师？ http://www.html-js.com/article/Large-search-front-team-column%202961 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions 前端实习生面试总结 http://www.cnblogs.com/xiaoruo/p/4665163.html 史上最全 前端开发面试问题及答案整理 https://github.com/hawx1993/Front-end-Interview-questions BAT及各大互联网公司2014前端笔试面试题：JavaScript篇 http://blog.jobbole.com/78738 前端开发面试题大收集 https://github.com/paddingme/Front-end-Web-Development-Interview-Question 收集的前端面试题和答案 https://github.com/qiu-deqing/FE-interview 如何面试前端工程师 http://www.zhihu.com/question/19568008 前端开发面试题 https://github.com/markyun/My-blog/blob/master/Front-end-Developer-Questions/Questions-and-Answers/README.md 牛客网-笔试面经 http://www.nowcoder.com/discuss?type=2 iconfont 地址 中文字体 http://www.zhihu.com/question/21253343 淘宝字库 http://iconfont.cn 字体 http://mux.alimama.com/fonts 制作教程 http://iconfont.cn/help/platform.html zhangxinxu-icommon http://www.zhangxinxu.com/wordpress/?s=icomoon icommon https://icomoon.io/app 用字体在网页中画ICON图标(推荐教程 http://imooc.com/learn/243 字体压缩工具 http://font-spider.org 前端开发工具 地址 IntelliJ IDEA 简体中文专题教程 https://github.com/judasn/IntelliJ-IDEA-Tutorial Webstorm,InterllIdea,Phpstorm http://t.cn/8kZZ1Uy SublimeText https://github.com/jikeytang/sublime-text Atom https://atom.io visual studio code https://code.visualstudio.com Fiddler 地址 Fiddler调试使用知多少(一)深入研究 http://www.cnblogs.com/tugenhua0707/p/4623317.html 微信fiddle http://www.cnblogs.com/strick/p/4570006.html 微信fiddle http://gaoboy.com/article/26.html Chrome 地址 Google Chrome 官方 https://developer.chrome.com/devtools Chrome - 基础 http://www.cnblogs.com/constantince/p/4565261.html Chrome - 进阶 http://www.cnblogs.com/constantince/p/4579121.html Chrome - 性能 http://www.cnblogs.com/constantince/p/4585983.html Chrome - 性能进阶 http://www.cnblogs.com/constantince/p/4607497.html Chrome - 移动 http://www.cnblogs.com/constantince/p/4624241.html Chrome - 使用技巧 http://www.cnblogs.com/liyunhua/p/4544738.html Chrome - Console控制台不完全指南 http://www.cnblogs.com/Wayou/p/chrome-console-tips-and-tricks.html Chrome - Workspace使浏览器变成IDE http://c7sky.com/chrome-devtools-workspace.html network面板 http://www.html-js.com/article/Nothing-blind%202975 chrome开发工具快捷键 http://anti-code.com/devtools-cheatsheet chrome调试工具常用功能整理 http://www.html-js.com/article/2327 Chrome 开发工具 Workspace 使用 http://www.iinterest.net/2014/05/09/chrome-dev-tool-workspace Chrome神器Vimium快捷键学习记录 http://www.cppblog.com/deercoder/archive/2011/10/22/158886.html sass调试-w3cplus http://www.w3cplus.com/sassguide/debug.html 如何更专业的使用Chrome开发者工具-w3cplus http://www.w3cplus.com/tools/how-to-use-chrome-devtools-like-a-pro.html chrome调试canvas http://sentsin.com/web/253.html chrome profiles1 https://developer.chrome.com/devtools/index chrome profiles2 http://h5dev.uc.cn/article-25-1.html chrome profiles3 http://www.oschina.net/translate/performance-optimisation-with-timeline-profiles chrome移动版调试 https://developer.chrome.com/devtools/docs/mobile-emulation chrome调试 http://ued.taobao.org/blog/2012/06/debug-with-chrome-dev-tool chrome的调试 http://www.cnblogs.com/QLeelulu/archive/2011/08/28/2156402.html chrome console 命令详解 https://developer.chrome.com/devtools/docs/commandline-api 查看事件绑定1 http://www.cnblogs.com/leonkao/p/3809655.html 查看事件绑定2 http://www.cnblogs.com/xiaoyao2011/p/3447421.html 神器——Chrome开发者工具(一 http://segmentfault.com/a/1190000000683599 奇趣百科性能优化(Chrome DevTools 中的 Timeline Profils 等工具使用介绍 https://xinranliu.me/2015-05-22-qiqu-performance chrome 开发者工具的 15 个小技巧 http://frontenddev.org/link/15-tips-of-chrome-developer-tools.html Chrome开发者工具不完全指南 http://1ke.co/course/361 Chrome 开发者工具使用技巧 http://segmentfault.com/a/1190000003882567 Firebug 地址 firebug视频教程 http://www.imooc.com/learn/137 firefox 模拟器 https://developer.mozilla.org/zh-CN/docs/Tools/WebIDE console.log 命令详解 http://www.cnblogs.com/ctriphire/p/4116207.html Firebug入门指南 http://www.ruanyifeng.com/blog/2008/06/firebug_tutorial.html Firebug控制台详解 http://www.ruanyifeng.com/blog/2011/03/firebug_console_tutorial.html 移动,微信调试 地址 浏览器端调试安卓 https://openstf.github.io 移动端前端开发调试 http://yujiangshui.com/multidevice-frontend-debug 使用 Chrome 远程调试 Android 设备 https://github.com/yujiangshui/CN-Chrome-DevTools/blob/remote-debugging/md/Use-Tools/remote-debugging.md mac移动端调试 http://plus.uc.cn/document/webapp/doc5.html mac移动端调试 http://www.mihtool.com 无线调试攻略 http://thx.github.io/mobile/debugging-in-mobile 无线调试攻略 http://yanhaijing.com/mobile/2014/12/17/web-debug-for-mobile 屌爆了,完美调试 微信webview(x5 http://www.jianshu.com/p/ccf124f1f74b 微信调试的那些事 http://liyaodong.com/2015/07/06/%E5%BE%AE%E4%BF%A1%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B 远程console http://jsconsole.com 微信调试工具 http://blog.qqbrowser.cc 各种真机远程调试方法汇总 https://github.com/jieyou/remote_inspect_web_on_real_device iOS Simulator 地址 Simulator https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/iOS_Simulator_Guide/Introduction/Introduction.html Xcode中的iOS模拟器(iOS Simulator的介绍和使用心得 http://www.crifan.com/intro_ios_simulator_in_xcode_and_usage_summary img 地址 loading img http://preloaders.net/en/circular 智图-图片优化平台 http://zhitu.isux.us 在线png优化 https://tinypng.com 生成二维码 地址 生成二维码 http://cli.im 浏览器同步 地址 puer https://github.com/leeluolee/puer liveReload http://livereload.com f5 http://getf5.com File Watchers http://geek100.com/2608 在线PPT制作 地址 nodePPT http://js8.in/2013/11/16/%E6%8E%A8%E8%8D%90nodeppt%EF%BC%9A%E4%BD%BF%E7%94%A8markdown%E8%AF%AD%E6%B3%95%E6%9D%A5%E5%86%99%E7%BD%91%E9%A1%B5ppt PPT https://github.com/ksky521/nodePPT reveal https://github.com/hakimel/reveal.js slippy https://github.com/Seldaek/slippy 前端导航网站 地址 界面清爽的前端导航 http://uxbees.com/index.html 前端导航 http://whycss.com 前端网址导航 http://www.daqianduan.com/nav 前端名录 http://sentsin.com/daohang 前端导航 http://123.jser.us 前端开发资源 http://www.css88.com/nav 网址导航 http://www.haourl.cn 前端开发仓库 - 众多效果的收集地 http://code.ciaoca.com 前端资源导航 https://github.com/jnoodle/f2e-collect F2E 前端导航 http://f2e.im/static/pages/nav/index.html 常用CDN 地址 新浪CDN http://lib.sinaapp.com 百度静态资源公共库 http://cdn.code.baidu.com 360网站卫士常用前端公共库CDN服务 http://libs.useso.com Bootstrap中文网开源项目免费 CDN 服务 http://www.bootcdn.cn 开放静态文件 CDN - 七牛 http://staticfile.org CDN加速 - jq22 http://www.jq22.com/cdn jQuery CDN http://code.jquery.com Google jQuery CDN http://www.google-jquery-cdn.com 微软CDN http://www.asp.net/ajax/cdn Git 地址 git-scm http://git-scm.com 廖雪峰-Git教程 http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 git-for-windows https://git-for-windows.github.io GitHub 添加 SSH keys http://daemon369.github.io/git/2015/03/10/add-ssh-keys-for-github gogithub http://www.worldhello.net/gotgithub/index.html git常规命令练习 http://pcottle.github.io/learnGitBranching git的资料整理 https://github.com/xirong/my-git 我所记录的git命令（非常实用） http://www.cnblogs.com/fanfan259/p/4810517.html 企业开发git工作流模式探索部分休整 https://github.com/xirong/my-git/blob/master/git-workflow-tutorial.md GitHub 漫游指南 https://github.com/phodal/github-roam GitHub秘籍 https://github.com/tiimgreen/github-cheat-sheet/blob/master/README.zh-cn.md 使用git和github进行协同开发流程 http://livoras.com/post/28 动画方式练习git http://onlywei.github.io/explain-git-with-d3 优秀JavaScript项目 地址 Angular和Webpack种子文件 https://github.com/AngularClass/angular2-webpack-starter Fis3面向前端的工程构建系统 https://github.com/fex-team/fis3 Fis3 DEMO https://github.com/fex-team/fis3-demo 前端JQuery系列:源码剖析 https://github.com/JsAaron/jQuery avalon框架 https://github.com/RubyLouvre/avalon Microsoft ChakraCore 微软的Chakra引擎 https://github.com/Microsoft/ChakraCore Quintus HTML游戏引擎 https://github.com/cykod/Quintus 一个用node.js搭建的有趣博客 https://github.com/STRML/strml.net Web前端助手–FeHelper（Chrome扩展） https://github.com/zxlie/FeHelper 百度前端技术学院 https://github.com/baidu-ife/ife Cheerio（node.js中的jQuery） https://github.com/cheeriojs/cheerio nodejs的一个聊天软件 类似微信 https://github.com/BryanYang/freechat 使用html5和node.js构建的网易云音乐 https://github.com/stkevintan/Cube babel ES6转换为ES5 https://github.com/babel/babel 一个JS富文本编辑器 https://github.com/fex-team/ueditor 一个JS脑图可视化工具 https://github.com/fex-team/kityminder-core 一个JS写的Flappy Bird Game https://github.com/ellisonleao/clumsy-bird 一个JS写的GBA模拟器 https://github.com/taisel/IodineGBA SegmentFault写的Markdown解析器 https://github.com/SegmentFault/HyperDown.js 基于node.js的Ghost博客 https://github.com/TryGhost/Ghost 学习react的demos https://github.com/ruanyf/react-demos","tags":[{"name":"前端资源","slug":"前端资源","permalink":"http://yaochuxia.github.io/tags/前端资源/"}]},{"title":"grunt,gulp常用插件","date":"2015-11-15T15:27:26.000Z","path":"2015/11/15/grunt-gulp常用插件/","text":"gulp是最近火起来的前端构建工具，大有赶超grunt之势，它和grunt这种构建工具比较像。 前端现在三足鼎立的构建工具（不算比较老的ant，yeoman），非fis，grunt，gulp莫属了 grunt特点 Grunt有一个完善的社区，插件丰富 它简单易学，你可以随便安装插件并配置它们 你不需要多先进的理念，也不需要任何经验 完善 – Grunt的插件数据： 根据社区的结果显示，共计3,439个插件，其中49个官方插件。 易用 – Grunt的插件丰富： 许多常见的任务都有现成的Grunt插件，而且有众多第三方插件，如：CoffeeScript，Handlebars，Jade，JsHint，Less，RequireJS，Sass，Styles。而且通过参考文档进行配置便可以使用。 Gulp和Grunt的异同点 易于使用：采用代码优于配置策略，Gulp让简单的事情继续简单，复杂的任务变得可管理。 高效：通过利用Node.js强大的流，不需要往磁盘写中间文件，可以更快地完成构建。 高质量：Gulp严格的插件指导方针，确保插件简单并且按你期望的方式工作。 易于学习：通过把API降到最少，你能在很短的时间内学会Gulp。构建工作就像你设想的一样：是一系列流管道. 易用 Gulp相比Grunt更简洁，而且遵循代码优于配置策略，维护Gulp更像是写代码。 高效Gulp相比Grunt更有设计感，核心设计基于Unix流的概念，通过管道连接，不需要写中间文件。 高质量 Gulp的每个插件只完成一个功能，这也是Unix的设计原则之一，各个功能通过流进行整合并完成复杂的任务。例如：Grunt的imagemin插件不仅压缩图片，同时还包括缓存功能。他表示，在Gulp中，缓存是另一个插件，可以被别的插件使用，这样就促进了插件的可重用性。目前官方列出的有673个插件。 易学 Gulp的核心API只有5个，掌握了5个API就学会了Gulp，之后便可以通过管道流组合自己想要的任务。 Gruntfile.js12345678910111213141516171819202122232425262728module.exports = function(grunt) &#123;grunt.initConfig(&#123; concat: &#123; 'dist/all.js': ['src/*.js'] &#125;, uglify: &#123; 'dist/all.min.js': ['dist/all.js'] &#125;, jshint: &#123; files: ['gruntfile.js', 'src/*.js'] &#125;, watch: &#123; files: ['gruntfile.js', 'src/*.js'], tasks: ['jshint', 'concat', 'uglify'] &#125;&#125;);// Load Our Pluginsgrunt.loadNpmTasks('grunt-contrib-jshint');grunt.loadNpmTasks('grunt-contrib-concat');grunt.loadNpmTasks('grunt-contrib-uglify');grunt.loadNpmTasks('grunt-contrib-watch');// Register Default Taskgrunt.registerTask('default', ['jshint', 'concat', 'uglify']);&#125;; Gulpfile.js123456789101112131415161718192021222324252627282930var gulp = require('gulp');var jshint = require('gulp-jshint');var concat = require('gulp-concat');var rename = require('gulp-rename');var uglify = require('gulp-uglify');// Lint JSgulp.task('lint', function() &#123;return gulp.src('src/*.js') .pipe(jshint()) .pipe(jshint.reporter('default'));&#125;);// Concat &amp; Minify JSgulp.task('minify', function()&#123;return gulp.src('src/*.js') .pipe(concat('all.js')) .pipe(gulp.dest('dist')) .pipe(rename('all.min.js')) .pipe(uglify()) .pipe(gulp.dest('dist'));&#125;);// Watch Our Filesgulp.task('watch', function() &#123;gulp.watch('src/*.js', ['lint', 'minify']);&#125;);// Defaultgulp.task('default', ['lint', 'minify', 'watch']); 差异和不同 流：Gulp是一个基于流的构建系统，使用代码优于配置的策略。 插件：Gulp的插件更纯粹，单一的功能，并坚持一个插件只做一件事。 代码优于配置：维护Gulp更像是写代码，而且Gulp遵循CommonJS规范，因此跟写Node程序没有差别。 没有产生中间文件 I/O流程的不同 使用Grunt的I/O过程中会产生一些中间态的临时文件，一些任务生成临时文件，其它任务可能会基于临时文件再做处理并生成最终的构建后文件。 而使用Gulp的优势就是利用流的方式进行文件的处理，通过管道将多个任务和操作连接起来，因此只有一次I/O的过程，流程更清晰，更纯粹。 Gulp的核心：流Gulp通过流和代码优于配置策略来尽量简化任务编写的工作。这看起来有点“像jQuery”的方法，把动作串起来创建构建任务。早在Unix的初期，流就已经存在了。流在Node.js生态系统中也扮演了重要的角色，类似于*nix将几乎所有设备抽象为文件一样，Node将几乎所有IO操作都抽象成了Stream的操作。因此用Gulp编写任务也可看作是用Node.js编写任务。当使用流时，Gulp去除了中间文件，只将最后的输出写入磁盘，整个过程因此变得更快。 为什么应该使用流？Node中的I/O操作是异步的，因此磁盘的读写和网络操作都需要传递回调函数。123456789var http = require('http');var fs = require('fs');var server = http.createServer(function (req, res) &#123; fs.readFile(__dirname + '/data.txt', function (err, data) &#123; res.end(data); &#125;);&#125;);server.listen(8000); 这个Node.js应用很简单，估计所有学习过Node的人都做过这样的练习，可以说是Node的Hello World了。这段代码没有任何问题，你使用node可以正常的运行起来，使用浏览器或者其他的http客户端都可以正常的访问运行程序主机的8000端口读取主机上的data.txt文件。但是这种方式隐含了一个潜在的问题，node会把整个data.txt文件都缓存到内存中以便响应客户端的请求（request），随着客户端请求的增加内存的消耗将是非常惊人的，而且客户端需要等待很长传输时间才能得到结果。让我们再看一看另外一种方式，使用流：12345678var http = require('http');var fs = require('fs');var server = http.createServer(function (req, res) &#123; var stream = fs.createReadStream(__dirname + '/data.txt'); stream.pipe(res);&#125;);server.listen(8000); Gulp的API gulp.task gulp.run gulp.watch gulp.src gulp.dest","tags":[]},{"title":"mac常用快捷键","date":"2015-10-09T06:21:02.000Z","path":"2015/10/09/mac常用快捷键/","text":"mac 常用的快捷大全 cmd+C：拷贝 cmd+V：粘贴 cmd+W：关闭窗口 cmd+Q：退出程序 cmd+I：显示文件/文件夹属性 cmd+Backspace：删除 cmd+shift+3：捕获整个屏幕 cmd+shift+4：捕获选择的区域 cmd+shift+4+space：捕获某个应用程序的窗口 cmd+F：在应用程序中搜索 cmd+Space：用Spotlight进行桌面搜索 fn+Backspace：相当于Windows里面的Delete键（笔记本键盘专用，台式机键盘有Delete键） 开机时，听到启动音后，按住Option（相当于Windows的Alt）键，可以选择从Windows或者Mac启动。 开机时，听到启动音后，按住“T”键，将使计算机进入目标磁盘状态，即通过USB连线，可以将苹果机当作USB硬盘使用。 组合键 功能 Command-A 选中最前面的 Finder 窗口中的所有项（如果未打开任何窗口则选中桌面内容） Option-Command-A 取消选择所有项 Shift-Command-A 打开“应用程序”文件夹 Command-C 拷贝所选项/文本至夹纸板 Shift-Command-C 打开“电脑”窗口 Command-D 复制所选项 Shift-Command-D 打开桌面文件夹 Command-E 推出 Command-F 查找任何匹配 Spotlight 属性的内容 Shift-Command-F 查找 Spotlight 文件名匹配项 Option-Command-F 导航到已打开的 Spotlight 窗口中的搜索栏 Shift-Command-G 前往文件夹 Shift-Command-H 打开当前所登录用户帐户的个人文件夹 Command-I 显示简介 Option-Command-I 显示检查器 Control-Command-I 获得摘要信息 Shift-Command-I 打开 iDisk Command-J 调出“显示”选项 Command-K 连接服务器 Shift-Command-K 打开“网络”窗口 Command-L 为所选项制作替身 Command-M 最小化窗口 Option-Command-M 最小化所有窗口 Command-N 新建 Finder 窗口 Shift-Command-N 新建文件夹 Option-Command-N 新建智能文件夹 Command-O 打开所选项 Shift-Command-Q 注销 Option-Shift-Command-Q 立即注销 Command-R 显示（替身的）原身 Command-T 添加到工具条 Shift-Command-T 添加到个人收藏 Option-Command-T 在 Finder 窗口中隐藏工具栏/显示工具栏 Shift-Command-U 打开“实用工具”文件夹 Command-V 粘贴 Command-W 关闭窗口 Option-Command-W 关闭所有窗口 Command-X 剪切 Option-Command-Y 幻灯片显示（Mac OS X 10.5 或更高版本） Command-Z 还原/重做 Command-1 以图标显示 Command-2 列表方式显示 Command-3 以分栏方式显示 Command-4 以 Cover Flow 方式显示（Mac OS X 10.5 或更高版本） Command-,（Command 加逗号键） 打开 Finder 偏好设置 Command-`（重音符键 - 美式英语键盘布局中 Tab 键的上方） 循环显示打开的 Finder 窗口 Command-Shift-? 打开 Mac 帮助 Option-Shift-Command-Esc（按住三秒钟）- 仅 Mac OS X v10.5、v10.6 或更高版本 强制退出最前面的应用程序 Command-[ 后退 Command-] 前进 Command-上箭头 打开所含文件夹 Control-Command-上箭头 在新窗口中打开所含文件夹 Command-下箭头 打开高亮显示的项 Command-Tab 切换应用程序 - 向前循环 Shift-Command-Tab 切换应用程序 - 向后循环 Command-Delete 移到废纸篓 Shift-Command-Delete 清倒废纸篓 锁屏 control+shift+开关按钮 option+command+开关按钮","tags":[{"name":"Mac 常用快捷键","slug":"Mac-常用快捷键","permalink":"http://yaochuxia.github.io/tags/Mac-常用快捷键/"}]},{"title":"hexo创建分类页面","date":"2015-09-29T12:00:51.000Z","path":"2015/09/29/hexo创建分类页面/","text":"基于hexo命令添加分类页面，并在菜单中显示页面链接 1.新建一个页面，命名为 categories 。命令如下: hexo new page categories 2.编辑刚新建的页面，将页面的类型设置为 categories,主题将自动为这个页面显示所有分类。 title: 分类 date: 2014-12-22 12:39:04 type: &quot;categories&quot; --- 注意：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如： title: 分类 date: 2014-12-22 12:39:04 type: &quot;categories&quot; comments: false --- 3.在菜单中添加链接。编辑主题的 _config.yml ，将 menu 中的 categories: /categories 注释去掉，如下: menu: home: / categories: /categories archives: /archives tags: /tags","tags":[{"name":"hexo命令添加一个分类页面。","slug":"hexo命令添加一个分类页面。","permalink":"http://yaochuxia.github.io/tags/hexo命令添加一个分类页面。/"}]},{"title":"在客户端用JavaScript数字实现导出格式为CSV的功能","date":"2015-09-22T13:52:41.000Z","path":"2015/09/22/在客户端用JavaScript实现导出格式为CSV的功能/","text":"在本地使用JavaScript做到这一点。必须分析你的数据到正确的CSV格式 在本地JavaScript做到这一点。必须分析你的数据到正确的CSV格式，这样（导出的数据为数组：1234567var data = [[\"name1\", \"city1\", \"some other info\"], [\"name2\", \"city2\", \"more info\"]];var csvContent = \"data:text/csv;charset=utf-8,\";data.forEach(function(infoArray, index)&#123; dataString = infoArray.join(\",\"); csvContent += index &lt; data.length ? dataString+ \"\\n\" : dataString;&#125;); 使用JavaScript的window.open和是encodeURI函数来下载CSV文件，如下所示:12var encodedUri = encodeURI(csvContent);window.open(encodedUri); 如果你想给你的文件一个特定的名字，你必须做的事情有点不同，因为这是不支持访问数据URI使用window.open方法。为了实现这一点，你可以创建一个隐藏的 DOM节点并设置其属性下载如下:12345678910111213141516171819202122232425262728 var encodedUri = encodeURI(csvContent); var link = document.createElement(\"a\"); link.setAttribute(\"href\", encodedUri); link.setAttribute(\"download\", \"my_data.csv\");link.click(); // 这将下载g名为“ my_data.csv ”的数据文件 $.ajax(&#123; url: \"/reports/export_reimbursesfile\", type: \"get\", data:&#123;name:name,fromdate:fromdate,enddate:enddate&#125;, success : function(data)&#123; var data = (data); console.log(data); var data = [[data], []]; var csvContent = \"data:text/csv;charset=utf-8,\"; data.forEach(function(infoArray, index)&#123; dataString = infoArray.join(\",\"); csvContent += index &lt; data.length ? dataString+ \"\\n\" : dataString; &#125;); var encodedUri = encodeURI(csvContent); var a = document.createElement(\"a\"); a.href = 'data:text/csv;charset=utf-8,'+encodedUri; a.setAttribute(\"href\", encodedUri); a.setAttribute(\"download\", \"报销列表.csv\"); a.click(); &#125; &#125;) http://stackoverflow.com/questions/14964035/how-to-export-javascript-array-info-to-csv-on-client-side 资料","tags":[{"name":"在本地JavaScript做到这一点","slug":"在本地JavaScript做到这一点","permalink":"http://yaochuxia.github.io/tags/在本地JavaScript做到这一点/"}]},{"title":"MAC xampp 启动失败","date":"2015-09-07T15:16:04.000Z","path":"2015/09/07/MAC-xampp-启动失败/","text":"解决命令行搭建环境的一些问题,先关闭mac自带的web服务。 解决1.先关闭mac自带的web服务。2.用下面的命令强制杀死所有 httpd 进程， sudo killall httpd 多运行几次，例如： sudo killall httpd No matching processes were found 然后在终端运行 sudo launchctl unload -w /System/Library/LaunchDaemons/org. apache.httpd.plist","tags":[{"name":"解决命令行搭建环境的一些问题","slug":"解决命令行搭建环境的一些问题","permalink":"http://yaochuxia.github.io/tags/解决命令行搭建环境的一些问题/"}]},{"title":"Mac版photoshop快捷键","date":"2015-08-01T08:20:33.000Z","path":"2015/08/01/Mac版photoshop快捷键/","text":"Windows和Mac的快捷键其实没什么不同，你只要把Ctrl换成Command，Alt换成Option即可 Mac下的Photoshop CS6 快捷键Windows和Mac的快捷键其实没什么不同，你只要把Ctrl换成Command，Alt换成Option即可。打开文件 - Command + O创建文档 - Command + N放大和缩小 - Command + 加号或减号。存储为Web格式- Command + Option+ Shift + S转换层 -转化的活性层发生时按Command + T自定义快捷键 - Option + Command+ Shift + K首选项 - Command + K色阶 – Command + L曲线 - Command + M色相/饱和度 – Command + U色彩平衡 - Command + B去色 – Command + Shift + U图像大小 - Command + Option + I新建图层 - Command + Shift + N液化 - Command + Shift + X反相 – Command + I满画布显示 – Command + 0标尺 - Command + R 显示或隐藏标尺都是一样快捷键。显示网格 - Command +’ 显示或隐藏网格都是一样快捷键。显示参考线 – Command +;显示或隐藏参考线都是一样快捷键。锁定参考线 – Option + Command+;画笔大小 -用 [ 和 ] 来调整。画笔的硬度 - 画笔的硬度可以从键盘修改使用{和} -这基本上像Shift + [和Shift +]。工具箱 （和windows一样了）移动工具 - V选框工具 - M *套索工具 - L *裁剪工具 - C *快速选择/魔术棒 - W *修复画笔 – J *橡皮擦 – E *渐变工具/油漆桶 - G *钢笔工具 - P *文字工具 - T *切换前景色/背景色 - X默认的前景色/背景色 - D矩形/圆形/多边形/椭圆工具 - U *减淡/加深/海绵工具 - O *历史记录画笔工具 – Y *旋转视图工具 - R抓手工具 – H","tags":[]},{"title":"练习node.js小例子","date":"2015-07-15T13:42:49.000Z","path":"2015/07/15/练习node-js小列子/","text":"使用 grunt 管理项目，自动运行启动node.js,服务，监听js文件自动重启服务。监听静态文件css，js自动压缩合并静态文件。 ##安装依赖 &amp; 启动 使用 grunt 管理项目，自动运行启动node.js 服务，监听js文件自动重启服务。监听静态文件css，js自动压缩合并静态文件。 使用前确保你已经安装了nodejs或者iojs了使用前还确保你已经安装了mongodb了启动mongodbnpm install安装node包依赖运行bower install安装项目前端框架(未来会使用)，npm install -g bower安装bowernpm install安装node包依赖直接grunt就可以运行了，会自动启动node.js服务 #由于Gruntfile.js使用的是coffeescript所以全局安装$ sudo npm install -g coffee-script 1.启动mongodb数据库$ mongod –config /usr/local/etc/mongod.conf 2.mongod 是 MongoDB 系统的主要后台进程。它处理数据请求，管理数据访问，执行后台管理操作。$ sudo mongod 进入在根目录安装依赖$ bower install$ npm install$ grunt #启动node.js服务和管理静态资源$ NODE_ENV=dev grunt #启动node.js服务【带日志中间件和mongoose日志】和管理静态资源文件夹结构说明 app/controllers/ 文件夹负责业务逻辑处理schemas/ 文件夹负责存放数据模式models/ 文件夹负责存放数据结构模型conf/ 文件夹负责路由订制，等配置文件lib/ 存放工具模块doc/ 学习文档themesdefault/默认皮肤source/ 前端静态资源文件存放目录views/ 存在静态模版文件相关依赖 依赖说明 ejs:模板引擎选择ejs，我只想要一个简单的帮我填充数据的模板。github 文档 ejs.coexpress:一个服务器端的基于 Node.js 的 JavaScript 开发框架。 官方文档 中文文档mongoose:让NodeJS更容易操作Mongodb数据库 官网 安装教程 brew官网 用来安装mongodbrobomongo 跨平台客户端Node.js 官方文档 Node.js 中文文档jade 模板引擎 官方文档superagent 是个 http 方面的库，可以发起 get 或 post 请求。githubcheerio 大家可以理解成一个 Node.js 版的 jquery，用来从网页中以 css selector 取数据，使用方式跟 jquery 一样一样的。github安装依赖 npm install PACKAGE_NAME –save $ npm install #安装 package.json 中的依赖包管理工具 NPM：https://www.npmjs.org/ (官方)CNPM：http://cnpmjs.org/ 、 http://npm.taobao.org/ (淘宝) 数据库 MongoDB：https://www.mongodb.com/Mongoose：http://mongoosejs.com/Mongoskin：node-mongoskin、Mongoskin Tutorial with ExamplesMongolab(500MB免费数据库)：https://mongolab.com/MySQL：https://github.com/felixge/node-mysql热门包 Grunt：http://gruntjs.com/ （英文）、 http://gruntjs.cn/ （中文）stylus：http://learnboost.github.io/stylus/Yeoman：http://yeoman.io/Socket.io：http://socket.io/mocha：http://visionmedia.github.io/mocha/uglifyjs：https://github.com/mishoo/UglifyJS2shelljs：http://documentup.com/arturadib/shelljs开发调试 debug：https://github.com/visionmedia/debugnode-inspector：https://github.com/node-inspector/node-inspector社区 cnodejs：http://cnodejs.org/nodejsbbs：http://nodejsbbs.com/forum.php","tags":[]},{"title":"CSS 设置背景颜色透明度","date":"2015-06-26T03:35:59.000Z","path":"2015/06/26/CSS-设置背景颜色透明度/","text":"标准background: rgba(0,0,0,.5); 兼容IEfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000); stylfilter unquote(&#39;progid:DXImageTransform.Microsoft.gradient(startColorstr=#7f000000,endColorstr=#7f000000)&#39;) rgba透明值 IEfilter值 0.1 19 0.2 33 0.3 4C 0.4 66 0.5 7F 0.6 99 0.7 B2 0.8 C8 0.9 E5 第二部分是19后面的六位。这个是六进制的颜色值。要跟rgb函数中的取值相同。比如rgb(0,0,0,)对应#000；都是黑色。 到这里，rgba的用法就可以兼容IE8了。","tags":[]},{"title":"sublime快捷键","date":"2015-06-25T12:56:40.000Z","path":"2015/06/25/sublime快捷键/","text":"⌃ + ↩︎ or ↩︎ 当前行下面新增一行然后跳至该行；⌃ + ⇧ + M则可以快速选择括号间的内容； 基本编辑（Basic Editing）⇣⇡⇠⇢ 就是⇣⇡⇠⇢，不是 KJHL。⌘ Command()⌃ Control⌥ Option(alt)⇧ Shift⇪ Caps Lock(大写)fn 功能键就是fn↩︎return/Enter ⌃ + ↩︎ or ↩︎ 当前行下面新增一行然后跳至该行；⌃ + ⇧ + ↩︎ 当前行上面增加一行并跳至该行；⌥ + ⇠/⇢ 进行逐词移动，相应的；⌥ + ⇧ + ⇠/⇢ 进行逐词选择；⌘ + ⇣/⇡移动到首行/尾行；⌘ + U 返回到历史光标位置(撤销)；⌃ + M可以快速的在起始括号和结尾括号间切换；⌃ + ⇧ + M则可以快速选择括号间的内容；⌃ + ⇧ + J 对于缩进型语言(例如Python)则可以使用；⌃ + ⌘ + D 复制整行；⇧ + ⌘ +p 打开控制面板⌃ + 控制台⌘ + 数字 标签切换⌘ + ⌥ +2 分为两屏⌃ + 数字 分屏时移动到不同的屏幕⌘ + delelte 删除光标前所有字符, 貌似是Mac快捷键⌥ + ⌘ + f 查找替换⌘ + t 文件跳转⌃ + g 行跳转, 类似vim中的num + gg⌘ + r函数跳转⌘ + /给选中行添加或去掉注释⌘ + [或 ⌘ + ] 智能行缩进⌘ + k + b 开关侧边栏 ##选择（Selecting） ⌘ + D 选择当前光标所在的词并高亮该词出现的所有位置；再次 ⌘ + D 选择该词出现的下一个位置；使用 ⌘ + U 进行回退，使用Esc退； ⌘ + K + K 从光标处删除到行末尾；⌃ + K 同上 ⌘ + KK 进行同时编辑，⌃ + ⇧ + L 可以将光标移动到每行的结束 ⌘ + ⇧ + ⇠ 选择光标到这一行第一个字符出现的位置⌃ + ⇧ + A 选择光标到这一行最前面的(包括缩进)位置 代码展开 ⌃ + K0 代码展开 改为大写或者小写 ⌃ + KL 改为小写⌃ + UK 改为大写 合并 ⌘ + J 可以把当前选中区域合并为一行 跳转指定行 ⌃ + G 然后输入行号以跳转到指定行： 组合跳转 ⌘ + P 我们可以进行后续输入以跳转到更精确的位置：@ 符号跳转：输入 @symbol 跳转到symbol符号所在的位置 关键字跳转：输入 #keyword 跳转到keyword所在的位置: 行号跳转：输入 :12 跳转到文件的第12行。 启动终端(Terminal插件) ⌃ + ⌘ + T设置启动 iTerm打开配置文件 preferences &gt; Package Setting &gt; Terminal &gt; Setting - Default设置&quot;terminal&quot;: &quot;iTerm.sh&quot;","tags":[]},{"title":"Git 创建操作","date":"2015-06-25T12:47:02.000Z","path":"2015/06/25/Git-创建操作/","text":"在本章中，我们将看到如何创建一个远程Git仓库，从现在开始，我们将会把它作为Git服务器。我们需要一个的Git服务器允许团队协作。 创建新用户 add new group[root@CentOS ~]# groupadd dev add new user[root@CentOS ~]# useradd -G devs -d /home/gituser -m -s /bin/bash gituser change password[root@CentOS ~]# passwd gituser上面的命令会产生以下结果。 Changing password for user gituser.New password:Retype new password:passwd: all authentication tokens updated successfully.创建一个裸库让我们初始化一个新的资料库使用init命令后面加上 -bare选项。它初始化没有工作目录库。按照惯例裸库必须命名为 .git。 [gituser@CentOS ~]$ pwd/home/gituser [gituser@CentOS ~]$ mkdir project.git [gituser@CentOS ~]$ cd project.git/ [gituser@CentOS project.git]$ ls [gituser@CentOS project.git]$ git --bare initInitialized empty Git repository in /home/gituser-m/project.git/ [gituser@CentOS project.git]$ lsbranches config description HEAD hooks info objects refs生成公共/私有RSA密钥对让我们遍历Git服务器端的配置过程中，使用ssh-keygen实用程序生成公共/私有RSA密钥对，我们将使用这些键进行用户认证。 打开一个终端并输入以下命令，直接按回车为每个输入。成功完成后，它会创建主目录 .ssh目录内。 tom@CentOS ~]$ pwd/home/tom [tom@CentOS ~]$ ssh-keygen上面的命令会产生以下结果。 Generating public/private rsa key pair.Enter file in which to save the key (/home/tom/.ssh/id_rsa): Press Enter OnlyCreated directory &#39;/home/tom/.ssh&#39;.Enter passphrase (empty for no passphrase): ---------------&gt; Press Enter OnlyEnter same passphrase again: ------------------------------&gt; Press Enter OnlyYour identification has been saved in /home/tom/.ssh/id_rsa.Your public key has been saved in /home/tom/.ssh/id_rsa.pub.The key fingerprint is:df:93:8c:a1:b8:b7:67:69:3a:1f:65:e8:0e:e9:25:a1 tom@CentOSThe key&#39;s randomart image is:+--[ RSA 2048]----+| || || ||.|| Soo || oB. || E = .= || oo==. . || ..+Oo|+—————–+ssh-keygen 已经产生了两个键，第一个是私有的（即id_rsa），另一个是公共（即id_rsa.pub文件）。 注: 切勿与他人共享你的私钥。添加键 authorized_keys假设有两个开发项目即Tom 和Jerry工作。两个用户生成公钥。让我们来看看如何使用这些密钥进行身份验证。 Tom 添加他的公钥服务器使用 ssh-copy-id这个命令下面给出 [tom@CentOS ~]$ pwd/home/tom [tom@CentOS ~]$ ssh-copy-id -i ~/.ssh/id_rsa.pub gituser@git.server.com上面的命令会产生以下结果。 gituser@git.server.com&#39;s password:Now try logging into the machine, with &quot;ssh &#39;gituser@git.server.com&#39;&quot;, and check in:.ssh/authorized_keysto make sure we haven&#39;t added extra keys that you weren&#39;t expecting.同样，Jerry 也增加了他的公共密钥服务器使用 ssh-copy-id 这个命令。 [jerry@CentOS ~]$ pwd/home/jerry [jerry@CentOS ~]$ ssh-copy-id -i ~/.ssh/id_rsa gituser@git.server.com上面的命令会产生以下结果。 gituser@git.server.com&#39;s password:Now try logging into the machine, with &quot;ssh &#39;gituser@git.server.com&#39;&quot;, and check in:.ssh/authorized_keysto make sure we haven&#39;t added extra keys that you weren&#39;t expecting.推修改到版本库我们已经创建了裸库在服务器上，并允许两个用户访问。从现在Tom 和 Jerry 可以把他们修改到版本库，将其添加为远程。 Git的init命令创建 .git 目录来存储元数据的存储库。每次读取配置从 .git/config 文件. Tom 创建一个新的目录，添加READE文件作为初始提交并提交他的变化。提交后，他确认提交信息，运行git日志命令。 [tom@CentOS ~]$ pwd/home/tom [tom@CentOS ~]$ mkdir tom_repo [tom@CentOS ~]$ cd tom_repo/ [tom@CentOS tom_repo]$ git initInitialized empty Git repository in /home/tom/tom_repo/.git/ [tom@CentOS tom_repo]$ echo &#39;TODO: Add contents for README&#39; &gt; README [tom@CentOS tom_repo]$ git status -s?? README [tom@CentOS tom_repo]$ git add . [tom@CentOS tom_repo]$ git status -sA README [tom@CentOS tom_repo]$ git commit -m &#39;Initial commit&#39;上面的命令会产生以下结果。 [master (root-commit) 19ae206] Initial commit1 files changed, 1 insertions(+), 0 deletions(-)create mode 100644 READMETom 执行git 的日志命令，检查日志消息。 [tom@CentOS tom_repo]$ git log上面的命令会产生以下结果。 commit 19ae20683fc460db7d127cf201a1429523b0e319Author: Tom CatDate: Wed Sep 11 07:32:56 2013 +0530 Initial commitTom 提交了他的变化到本地资源库。现在是时候将更改到远程仓库。但在此之前，我们必须添加作为远程仓库，这是一个时间的操作。在此之后，他可以放心地推送到远程存储库的更改。 注: 默认情况下，Git的推到匹配的分支：对于每一个分支退出本地端的远程端更新，如果已经存在具有相同名称的一个分支。在我们的教程每次我推原点主分支的变化，根据您的要求，使用适当的分支名。","tags":[]},{"title":"Git 生命周期","date":"2015-06-25T12:42:19.000Z","path":"2015/06/25/Git-生命周期/","text":"在本章中，我们将讨论的Git的生命周期。在后面的章节中，我们将看到的Git命令为每个操作。 一般工作流程是这样的： 1.克隆Git仓库作为工作副本。 2.可以添加/编辑文件，修改工作副本。 3.如果有必要，你还服用其他开发人员的变化，更新工作副本。 4.审查前提交。 5.提交修改。如果一切都很好，然后推到存储库的更改。 6.提交之后，如果知道是什么错误，那么纠正最后一次提交，并推送修改到版本库。","tags":[]},{"title":"git环境(安装)","date":"2015-06-25T09:24:11.000Z","path":"2015/06/25/git教程/","text":"使用的是GNU/ Linux 发行版Debian基本apt-get命令就可以搞定一切。 ##Git客户端安装如果使用的是GNU/ Linux 发行版Debian基本apt-get命令就可以搞定一切。[ubuntu ~]$ sudo apt-get install git-core[sudo] password for ubuntu: [ubuntu ~]$ git --versiongit version 1.8.1.2 而且，如果使用的是基于RPM的GNU/ Linux发行版使用yum命令，如下：[CentOS ~]$su -Password: [CentOS ~]# yum -y install git-core [CentOS ~]# git --versiongit version 1.7.1 ##定义Git环境Git提供git 的配置工具，它允许设置配置变量。 Git会把所有的全局配置.gitconfig 文件位于主目录。要设置这些为全局配置值，添加 -global选项，如果省略 -global选项，那么配置是具体当前的Git存储库。 还可以设置系统范围内的配置。 Git存储这些值是在/etc/gitconfig文件，其中包含的配置系统上的每一个用户和资源库。要设置这些值，必须有root权限，并使用 -system 选项。 上面的代码编译和执行时，它会产生以下结果： ##设置用户名此信息用于Git的每个提交。[jerry@CentOS project]$ git config --global user.name &quot;Jerry Mouse&quot; ##设置电子邮件ID此信息用于Git的每个提交。[jerry@CentOS project]$ git config --global user.email &quot;jerry@yiibai.com&quot; ##避免PULLING提交合并先从远程资源库的最新变化，如果这些变化是不同的，默认情况下，Git 创建合并提交。我们可以通过以下设置来避免这种。jerry@CentOS project]$ git config --global branch.autosetuprebase always ##颜色高亮下面的命令使颜色突出显示在控制台的Git。[jerry@CentOS project]$ git config --global color.ui true [jerry@CentOS project]$ git config --global color.status auto [jerry@CentOS project]$ git config --global color.branch auto ##设置默认编辑器默认情况下，Git的使用系统默认取自VISUAL或EDITOR环境变量的编辑器。我们可以设定一个不同的使用git 配置。[jerry@CentOS project]$ git config --global core.editor vim ##设置默认的合并工具Git不会提供一个默认的合并工具整合到工作树冲突的更改。我们可以设置默认的合并工具，通过启用以下设置。[jerry@CentOS project]$ git config --global merge.tool vimdiff ##列出GIT设置为了验证自己的Git设置本地存储库使用git 的config-list命令，如下所示。","tags":[]},{"title":"我的Hexo博客","date":"2015-06-12T11:14:53.000Z","path":"2015/06/12/我的Hexo博客演示/","text":"什么是Hexo 首先Hexo是一款基于Node.js的静态博客，它是由台湾的一位大学生写出来的，支持很多主题和Markdown，很炫酷并且也很好用，现在已经可以支持多说了，很多人都在使用；如果你想Geek一下，可以尝试一下自己搭建一款Hexo博客。 二、本地搭建Hexo因为Hexo是静态博客，所以首先得在本地上搭建，网上的教程很多，诸位可以自己百度，这里重点是如何在Coding的演示平台上部署，所以只略说一下，不懂的各位可以看官网的Docs。 需要安装Node.js和Git（也可使用msysGit代替Git）右键任意地方，选择“Git Bush Here” 输入以下代码安装Hexo npm install -g hexo新建一个文件夹作为Hexo的文件夹，右键“Git Bush Here”输入以下代码建立一个Hexo网站 hexo init npm install关于更多本地搭建的内容，推荐参考Zippera’s blog上的教程 三、Coding上创建一个新项目在Coding上创建一个新项目，获取这个项目的地址（这里使用SSH地址） 四、发布到Coding第一种方法打开Hexo本地文件夹的“_config.yml”，编辑以下代码，记得每一个冒号后面要有一个空格 deploy: //此行留空 type: github //此处为github，不用修改 repository: git@coding.net:ryu/Hexo-demo.git //填入上面你获得的项目地址 branch: master //一般为master第一次使用的新用户需要设置SSH公钥，生成的方法可以参考Generating SSH keys,生成成功后在Coding的设置里添加新公钥。 添加后，输入 ssh -T git@coding.net获得 Coding.net Tips : [Hello ! You’ve conected to Coding.net by SSH successfully! ]代表公钥添加成功，之后每次使用 hexo deploy –generate便可以deploy到Coding上. 第二种方法你也可以直接在generate之后，通过Git的方式将生成的public文件夹里的所有文件push到你的Coding项目，也许比较麻烦，但是我们可以使用Git软件如Scourcetree或者GitHub for Windows。 五、部署演示平台当你把你的静态网站上传到Coding之后，就可以着手部署演示了，Coding的演示平台支持静态网页，所以其实非常简单。 当所有设置完后，点选一键部署，然后就是耐心等待，当看到正在运行后就可以访问了。 常见的hexo命令npm install hexo -g 安装npm update hexo -g 升级hexo init blog 初始化，生成文件夹blogcd blog 进入blog文件npm install 安装依赖库hexo server 运行测试 简写hexo n &quot;我的博客&quot; == hexo new &quot;我的博客&quot; 新建文章hexo p == hexo publishhexo g == hexo generate 生成hexo s == hexo server 启动服务预览hexo d == hexo deploy 部署 服务器hexo server Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s 静态模式hexo server -p 5000 更改单口hexo server -i 192168.1.1 自定义ip hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g#生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动 完成后部署两个命令的作用是相同的hexo generate --deployhexo deploy --generatehexo deploy -ghexo server -g 草稿hexo new draft &quot;new draft&quot; 新建草稿hexo publish [layout] &lt;title&gt; 变成正式文章 模版hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）hexo deploy #将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt;hexo new photo &quot;My Gallery&quot;hexo new &quot;Hello World&quot; --lang tw","tags":[]},{"title":"Git常用命令","date":"2015-06-12T10:29:40.000Z","path":"2015/06/12/常用命令/","text":"git 查看，添加，提交，删除，找回，重置修改文件，查看文件diff，查看提交纪录,查看、切换、创建和删除分支… 查看、添加、提交、删除、找回，重置修改文件git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am “some comments” git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异 git diff git diff # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tigMac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支git br -r # 查看远程分支 git br # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b # 创建新的分支，并且切换过去 git co -b # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebasegit merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b origin/ # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin # 创建远程分支， origin是远程仓库名 git push origin : # 创建远程分支 git push origin : #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理GitHubgit remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop","tags":[]},{"title":"常用shell命令笔记","date":"2015-04-01T15:13:06.000Z","path":"2015/04/01/常用shell命令笔记/","text":"常用shell命令node 版本查看，安装brew，npm全局更新npm，github 下载库，github 下载库 node 版本查看node -v 或者 node -version 安装brewruby -e&quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)” npm全局更新npmsudo npm install npm -g github 下载库git clone https://github.com/yaochuxia/JSLite.git sublime 命令启动 subl /ln -s /Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl /usr/local/bin/subl 查看当前目录路径pwd 查看当前目录文件ls 查看全部文件 包括隐藏文件ls -a 进入文件夹｀cd 文件夹名字｀ 进入父级目录cd ../../ 创建目录mkdir 目录名字 删除文件rm -rf 文件名字 gem ruby下载库的工具gem 安装ruby jekyll框架gem install jekyll 更换gem源gem sources -a http://ruby.taobao.org/ 在sublime text 里打开当前文件alias subl=\\&#39;&#39;/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl&#39;\\&#39;","tags":[]}]